
spot-micro-avr.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  000015c0  00001654  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000015c0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000639  0080010c  0080010c  00001660  2**0
                  ALLOC
  3 .stab         00003198  00000000  00000000  00001660  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003abe  00000000  00000000  000047f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000082b6  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000082c8  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  00008304  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  000088f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00008e9a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  00008eb4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
       2:	00 00       	nop
       4:	4e c0       	rjmp	.+156    	; 0xa2 <__bad_interrupt>
       6:	00 00       	nop
       8:	4c c0       	rjmp	.+152    	; 0xa2 <__bad_interrupt>
       a:	00 00       	nop
       c:	4a c0       	rjmp	.+148    	; 0xa2 <__bad_interrupt>
       e:	00 00       	nop
      10:	48 c0       	rjmp	.+144    	; 0xa2 <__bad_interrupt>
      12:	00 00       	nop
      14:	46 c0       	rjmp	.+140    	; 0xa2 <__bad_interrupt>
      16:	00 00       	nop
      18:	44 c0       	rjmp	.+136    	; 0xa2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	42 c0       	rjmp	.+132    	; 0xa2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	40 c0       	rjmp	.+128    	; 0xa2 <__bad_interrupt>
      22:	00 00       	nop
      24:	3e c0       	rjmp	.+124    	; 0xa2 <__bad_interrupt>
      26:	00 00       	nop
      28:	3c c0       	rjmp	.+120    	; 0xa2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	84 c3       	rjmp	.+1800   	; 0x736 <__vector_11>
      2e:	00 00       	nop
      30:	38 c0       	rjmp	.+112    	; 0xa2 <__bad_interrupt>
      32:	00 00       	nop
      34:	36 c0       	rjmp	.+108    	; 0xa2 <__bad_interrupt>
      36:	00 00       	nop
      38:	34 c0       	rjmp	.+104    	; 0xa2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	32 c0       	rjmp	.+100    	; 0xa2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	30 c0       	rjmp	.+96     	; 0xa2 <__bad_interrupt>
      42:	00 00       	nop
      44:	2e c0       	rjmp	.+92     	; 0xa2 <__bad_interrupt>
      46:	00 00       	nop
      48:	2c c0       	rjmp	.+88     	; 0xa2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2a c0       	rjmp	.+84     	; 0xa2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	28 c0       	rjmp	.+80     	; 0xa2 <__bad_interrupt>
      52:	00 00       	nop
      54:	26 c0       	rjmp	.+76     	; 0xa2 <__bad_interrupt>
      56:	00 00       	nop
      58:	24 c0       	rjmp	.+72     	; 0xa2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	22 c0       	rjmp	.+68     	; 0xa2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	20 c0       	rjmp	.+64     	; 0xa2 <__bad_interrupt>
      62:	00 00       	nop
      64:	1e c0       	rjmp	.+60     	; 0xa2 <__bad_interrupt>
	...

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 ec       	ldi	r30, 0xC0	; 192
      7c:	f5 e1       	ldi	r31, 0x15	; 21
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ac 30       	cpi	r26, 0x0C	; 12
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	ac e0       	ldi	r26, 0x0C	; 12
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a5 34       	cpi	r26, 0x45	; 69
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 ae 0a 	call	0x155c	; 0x155c <main>
      9e:	0c 94 de 0a 	jmp	0x15bc	; 0x15bc <_exit>

000000a2 <__bad_interrupt>:
      a2:	ae cf       	rjmp	.-164    	; 0x0 <__vectors>

000000a4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      a4:	cf 93       	push	r28
      a6:	df 93       	push	r29
      a8:	00 d0       	rcall	.+0      	; 0xaa <pvPortMalloc+0x6>
      aa:	00 d0       	rcall	.+0      	; 0xac <pvPortMalloc+0x8>
      ac:	cd b7       	in	r28, 0x3d	; 61
      ae:	de b7       	in	r29, 0x3e	; 62
      b0:	9c 83       	std	Y+4, r25	; 0x04
      b2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
      b4:	1a 82       	std	Y+2, r1	; 0x02
      b6:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      b8:	31 d6       	rcall	.+3170   	; 0xd1c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
      ba:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <pucAlignedHeap.2010>
      be:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <pucAlignedHeap.2010+0x1>
      c2:	89 2b       	or	r24, r25
      c4:	31 f4       	brne	.+12     	; 0xd2 <pvPortMalloc+0x2e>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
      c6:	8d e0       	ldi	r24, 0x0D	; 13
      c8:	91 e0       	ldi	r25, 0x01	; 1
      ca:	90 93 eb 06 	sts	0x06EB, r25	; 0x8006eb <pucAlignedHeap.2010+0x1>
      ce:	80 93 ea 06 	sts	0x06EA, r24	; 0x8006ea <pucAlignedHeap.2010>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
      d2:	20 91 e8 06 	lds	r18, 0x06E8	; 0x8006e8 <xNextFreeByte>
      d6:	30 91 e9 06 	lds	r19, 0x06E9	; 0x8006e9 <xNextFreeByte+0x1>
      da:	8b 81       	ldd	r24, Y+3	; 0x03
      dc:	9c 81       	ldd	r25, Y+4	; 0x04
      de:	82 0f       	add	r24, r18
      e0:	93 1f       	adc	r25, r19
      e2:	8b 3d       	cpi	r24, 0xDB	; 219
      e4:	95 40       	sbci	r25, 0x05	; 5
      e6:	38 f5       	brcc	.+78     	; 0x136 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
      e8:	20 91 e8 06 	lds	r18, 0x06E8	; 0x8006e8 <xNextFreeByte>
      ec:	30 91 e9 06 	lds	r19, 0x06E9	; 0x8006e9 <xNextFreeByte+0x1>
      f0:	8b 81       	ldd	r24, Y+3	; 0x03
      f2:	9c 81       	ldd	r25, Y+4	; 0x04
      f4:	28 0f       	add	r18, r24
      f6:	39 1f       	adc	r19, r25
      f8:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <xNextFreeByte>
      fc:	90 91 e9 06 	lds	r25, 0x06E9	; 0x8006e9 <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     100:	82 17       	cp	r24, r18
     102:	93 07       	cpc	r25, r19
     104:	c0 f4       	brcc	.+48     	; 0x136 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     106:	20 91 ea 06 	lds	r18, 0x06EA	; 0x8006ea <pucAlignedHeap.2010>
     10a:	30 91 eb 06 	lds	r19, 0x06EB	; 0x8006eb <pucAlignedHeap.2010+0x1>
     10e:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <xNextFreeByte>
     112:	90 91 e9 06 	lds	r25, 0x06E9	; 0x8006e9 <xNextFreeByte+0x1>
     116:	82 0f       	add	r24, r18
     118:	93 1f       	adc	r25, r19
     11a:	9a 83       	std	Y+2, r25	; 0x02
     11c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     11e:	20 91 e8 06 	lds	r18, 0x06E8	; 0x8006e8 <xNextFreeByte>
     122:	30 91 e9 06 	lds	r19, 0x06E9	; 0x8006e9 <xNextFreeByte+0x1>
     126:	8b 81       	ldd	r24, Y+3	; 0x03
     128:	9c 81       	ldd	r25, Y+4	; 0x04
     12a:	82 0f       	add	r24, r18
     12c:	93 1f       	adc	r25, r19
     12e:	90 93 e9 06 	sts	0x06E9, r25	; 0x8006e9 <xNextFreeByte+0x1>
     132:	80 93 e8 06 	sts	0x06E8, r24	; 0x8006e8 <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     136:	ff d5       	rcall	.+3070   	; 0xd36 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     138:	89 81       	ldd	r24, Y+1	; 0x01
     13a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	0f 90       	pop	r0
     142:	0f 90       	pop	r0
     144:	df 91       	pop	r29
     146:	cf 91       	pop	r28
     148:	08 95       	ret

0000014a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     14a:	cf 93       	push	r28
     14c:	df 93       	push	r29
     14e:	00 d0       	rcall	.+0      	; 0x150 <vPortFree+0x6>
     150:	cd b7       	in	r28, 0x3d	; 61
     152:	de b7       	in	r29, 0x3e	; 62
     154:	9a 83       	std	Y+2, r25	; 0x02
     156:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     158:	00 00       	nop
     15a:	0f 90       	pop	r0
     15c:	0f 90       	pop	r0
     15e:	df 91       	pop	r29
     160:	cf 91       	pop	r28
     162:	08 95       	ret

00000164 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     164:	cf 93       	push	r28
     166:	df 93       	push	r29
     168:	cd b7       	in	r28, 0x3d	; 61
     16a:	de b7       	in	r29, 0x3e	; 62
     16c:	28 97       	sbiw	r28, 0x08	; 8
     16e:	0f b6       	in	r0, 0x3f	; 63
     170:	f8 94       	cli
     172:	de bf       	out	0x3e, r29	; 62
     174:	0f be       	out	0x3f, r0	; 63
     176:	cd bf       	out	0x3d, r28	; 61
     178:	9c 83       	std	Y+4, r25	; 0x04
     17a:	8b 83       	std	Y+3, r24	; 0x03
     17c:	7e 83       	std	Y+6, r23	; 0x06
     17e:	6d 83       	std	Y+5, r22	; 0x05
     180:	58 87       	std	Y+8, r21	; 0x08
     182:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     184:	8b 81       	ldd	r24, Y+3	; 0x03
     186:	9c 81       	ldd	r25, Y+4	; 0x04
     188:	21 e1       	ldi	r18, 0x11	; 17
     18a:	fc 01       	movw	r30, r24
     18c:	20 83       	st	Z, r18
	pxTopOfStack--;
     18e:	8b 81       	ldd	r24, Y+3	; 0x03
     190:	9c 81       	ldd	r25, Y+4	; 0x04
     192:	01 97       	sbiw	r24, 0x01	; 1
     194:	9c 83       	std	Y+4, r25	; 0x04
     196:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     198:	8b 81       	ldd	r24, Y+3	; 0x03
     19a:	9c 81       	ldd	r25, Y+4	; 0x04
     19c:	22 e2       	ldi	r18, 0x22	; 34
     19e:	fc 01       	movw	r30, r24
     1a0:	20 83       	st	Z, r18
	pxTopOfStack--;
     1a2:	8b 81       	ldd	r24, Y+3	; 0x03
     1a4:	9c 81       	ldd	r25, Y+4	; 0x04
     1a6:	01 97       	sbiw	r24, 0x01	; 1
     1a8:	9c 83       	std	Y+4, r25	; 0x04
     1aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1ac:	8b 81       	ldd	r24, Y+3	; 0x03
     1ae:	9c 81       	ldd	r25, Y+4	; 0x04
     1b0:	23 e3       	ldi	r18, 0x33	; 51
     1b2:	fc 01       	movw	r30, r24
     1b4:	20 83       	st	Z, r18
	pxTopOfStack--;
     1b6:	8b 81       	ldd	r24, Y+3	; 0x03
     1b8:	9c 81       	ldd	r25, Y+4	; 0x04
     1ba:	01 97       	sbiw	r24, 0x01	; 1
     1bc:	9c 83       	std	Y+4, r25	; 0x04
     1be:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1c0:	8d 81       	ldd	r24, Y+5	; 0x05
     1c2:	9e 81       	ldd	r25, Y+6	; 0x06
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1c8:	29 81       	ldd	r18, Y+1	; 0x01
     1ca:	8b 81       	ldd	r24, Y+3	; 0x03
     1cc:	9c 81       	ldd	r25, Y+4	; 0x04
     1ce:	fc 01       	movw	r30, r24
     1d0:	20 83       	st	Z, r18
	pxTopOfStack--;
     1d2:	8b 81       	ldd	r24, Y+3	; 0x03
     1d4:	9c 81       	ldd	r25, Y+4	; 0x04
     1d6:	01 97       	sbiw	r24, 0x01	; 1
     1d8:	9c 83       	std	Y+4, r25	; 0x04
     1da:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     1dc:	89 81       	ldd	r24, Y+1	; 0x01
     1de:	9a 81       	ldd	r25, Y+2	; 0x02
     1e0:	89 2f       	mov	r24, r25
     1e2:	99 27       	eor	r25, r25
     1e4:	9a 83       	std	Y+2, r25	; 0x02
     1e6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1e8:	29 81       	ldd	r18, Y+1	; 0x01
     1ea:	8b 81       	ldd	r24, Y+3	; 0x03
     1ec:	9c 81       	ldd	r25, Y+4	; 0x04
     1ee:	fc 01       	movw	r30, r24
     1f0:	20 83       	st	Z, r18
	pxTopOfStack--;
     1f2:	8b 81       	ldd	r24, Y+3	; 0x03
     1f4:	9c 81       	ldd	r25, Y+4	; 0x04
     1f6:	01 97       	sbiw	r24, 0x01	; 1
     1f8:	9c 83       	std	Y+4, r25	; 0x04
     1fa:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     1fc:	8b 81       	ldd	r24, Y+3	; 0x03
     1fe:	9c 81       	ldd	r25, Y+4	; 0x04
     200:	fc 01       	movw	r30, r24
     202:	10 82       	st	Z, r1
	pxTopOfStack--;
     204:	8b 81       	ldd	r24, Y+3	; 0x03
     206:	9c 81       	ldd	r25, Y+4	; 0x04
     208:	01 97       	sbiw	r24, 0x01	; 1
     20a:	9c 83       	std	Y+4, r25	; 0x04
     20c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     20e:	8b 81       	ldd	r24, Y+3	; 0x03
     210:	9c 81       	ldd	r25, Y+4	; 0x04
     212:	20 e8       	ldi	r18, 0x80	; 128
     214:	fc 01       	movw	r30, r24
     216:	20 83       	st	Z, r18
	pxTopOfStack--;
     218:	8b 81       	ldd	r24, Y+3	; 0x03
     21a:	9c 81       	ldd	r25, Y+4	; 0x04
     21c:	01 97       	sbiw	r24, 0x01	; 1
     21e:	9c 83       	std	Y+4, r25	; 0x04
     220:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     222:	8b 81       	ldd	r24, Y+3	; 0x03
     224:	9c 81       	ldd	r25, Y+4	; 0x04
     226:	fc 01       	movw	r30, r24
     228:	10 82       	st	Z, r1
	pxTopOfStack--;
     22a:	8b 81       	ldd	r24, Y+3	; 0x03
     22c:	9c 81       	ldd	r25, Y+4	; 0x04
     22e:	01 97       	sbiw	r24, 0x01	; 1
     230:	9c 83       	std	Y+4, r25	; 0x04
     232:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     234:	8b 81       	ldd	r24, Y+3	; 0x03
     236:	9c 81       	ldd	r25, Y+4	; 0x04
     238:	22 e0       	ldi	r18, 0x02	; 2
     23a:	fc 01       	movw	r30, r24
     23c:	20 83       	st	Z, r18
	pxTopOfStack--;
     23e:	8b 81       	ldd	r24, Y+3	; 0x03
     240:	9c 81       	ldd	r25, Y+4	; 0x04
     242:	01 97       	sbiw	r24, 0x01	; 1
     244:	9c 83       	std	Y+4, r25	; 0x04
     246:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	23 e0       	ldi	r18, 0x03	; 3
     24e:	fc 01       	movw	r30, r24
     250:	20 83       	st	Z, r18
	pxTopOfStack--;
     252:	8b 81       	ldd	r24, Y+3	; 0x03
     254:	9c 81       	ldd	r25, Y+4	; 0x04
     256:	01 97       	sbiw	r24, 0x01	; 1
     258:	9c 83       	std	Y+4, r25	; 0x04
     25a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     25c:	8b 81       	ldd	r24, Y+3	; 0x03
     25e:	9c 81       	ldd	r25, Y+4	; 0x04
     260:	24 e0       	ldi	r18, 0x04	; 4
     262:	fc 01       	movw	r30, r24
     264:	20 83       	st	Z, r18
	pxTopOfStack--;
     266:	8b 81       	ldd	r24, Y+3	; 0x03
     268:	9c 81       	ldd	r25, Y+4	; 0x04
     26a:	01 97       	sbiw	r24, 0x01	; 1
     26c:	9c 83       	std	Y+4, r25	; 0x04
     26e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     270:	8b 81       	ldd	r24, Y+3	; 0x03
     272:	9c 81       	ldd	r25, Y+4	; 0x04
     274:	25 e0       	ldi	r18, 0x05	; 5
     276:	fc 01       	movw	r30, r24
     278:	20 83       	st	Z, r18
	pxTopOfStack--;
     27a:	8b 81       	ldd	r24, Y+3	; 0x03
     27c:	9c 81       	ldd	r25, Y+4	; 0x04
     27e:	01 97       	sbiw	r24, 0x01	; 1
     280:	9c 83       	std	Y+4, r25	; 0x04
     282:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     284:	8b 81       	ldd	r24, Y+3	; 0x03
     286:	9c 81       	ldd	r25, Y+4	; 0x04
     288:	26 e0       	ldi	r18, 0x06	; 6
     28a:	fc 01       	movw	r30, r24
     28c:	20 83       	st	Z, r18
	pxTopOfStack--;
     28e:	8b 81       	ldd	r24, Y+3	; 0x03
     290:	9c 81       	ldd	r25, Y+4	; 0x04
     292:	01 97       	sbiw	r24, 0x01	; 1
     294:	9c 83       	std	Y+4, r25	; 0x04
     296:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     298:	8b 81       	ldd	r24, Y+3	; 0x03
     29a:	9c 81       	ldd	r25, Y+4	; 0x04
     29c:	27 e0       	ldi	r18, 0x07	; 7
     29e:	fc 01       	movw	r30, r24
     2a0:	20 83       	st	Z, r18
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2ac:	8b 81       	ldd	r24, Y+3	; 0x03
     2ae:	9c 81       	ldd	r25, Y+4	; 0x04
     2b0:	28 e0       	ldi	r18, 0x08	; 8
     2b2:	fc 01       	movw	r30, r24
     2b4:	20 83       	st	Z, r18
	pxTopOfStack--;
     2b6:	8b 81       	ldd	r24, Y+3	; 0x03
     2b8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ba:	01 97       	sbiw	r24, 0x01	; 1
     2bc:	9c 83       	std	Y+4, r25	; 0x04
     2be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2c0:	8b 81       	ldd	r24, Y+3	; 0x03
     2c2:	9c 81       	ldd	r25, Y+4	; 0x04
     2c4:	29 e0       	ldi	r18, 0x09	; 9
     2c6:	fc 01       	movw	r30, r24
     2c8:	20 83       	st	Z, r18
	pxTopOfStack--;
     2ca:	8b 81       	ldd	r24, Y+3	; 0x03
     2cc:	9c 81       	ldd	r25, Y+4	; 0x04
     2ce:	01 97       	sbiw	r24, 0x01	; 1
     2d0:	9c 83       	std	Y+4, r25	; 0x04
     2d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2d4:	8b 81       	ldd	r24, Y+3	; 0x03
     2d6:	9c 81       	ldd	r25, Y+4	; 0x04
     2d8:	20 e1       	ldi	r18, 0x10	; 16
     2da:	fc 01       	movw	r30, r24
     2dc:	20 83       	st	Z, r18
	pxTopOfStack--;
     2de:	8b 81       	ldd	r24, Y+3	; 0x03
     2e0:	9c 81       	ldd	r25, Y+4	; 0x04
     2e2:	01 97       	sbiw	r24, 0x01	; 1
     2e4:	9c 83       	std	Y+4, r25	; 0x04
     2e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2e8:	8b 81       	ldd	r24, Y+3	; 0x03
     2ea:	9c 81       	ldd	r25, Y+4	; 0x04
     2ec:	21 e1       	ldi	r18, 0x11	; 17
     2ee:	fc 01       	movw	r30, r24
     2f0:	20 83       	st	Z, r18
	pxTopOfStack--;
     2f2:	8b 81       	ldd	r24, Y+3	; 0x03
     2f4:	9c 81       	ldd	r25, Y+4	; 0x04
     2f6:	01 97       	sbiw	r24, 0x01	; 1
     2f8:	9c 83       	std	Y+4, r25	; 0x04
     2fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	22 e1       	ldi	r18, 0x12	; 18
     302:	fc 01       	movw	r30, r24
     304:	20 83       	st	Z, r18
	pxTopOfStack--;
     306:	8b 81       	ldd	r24, Y+3	; 0x03
     308:	9c 81       	ldd	r25, Y+4	; 0x04
     30a:	01 97       	sbiw	r24, 0x01	; 1
     30c:	9c 83       	std	Y+4, r25	; 0x04
     30e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     310:	8b 81       	ldd	r24, Y+3	; 0x03
     312:	9c 81       	ldd	r25, Y+4	; 0x04
     314:	23 e1       	ldi	r18, 0x13	; 19
     316:	fc 01       	movw	r30, r24
     318:	20 83       	st	Z, r18
	pxTopOfStack--;
     31a:	8b 81       	ldd	r24, Y+3	; 0x03
     31c:	9c 81       	ldd	r25, Y+4	; 0x04
     31e:	01 97       	sbiw	r24, 0x01	; 1
     320:	9c 83       	std	Y+4, r25	; 0x04
     322:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     324:	8b 81       	ldd	r24, Y+3	; 0x03
     326:	9c 81       	ldd	r25, Y+4	; 0x04
     328:	24 e1       	ldi	r18, 0x14	; 20
     32a:	fc 01       	movw	r30, r24
     32c:	20 83       	st	Z, r18
	pxTopOfStack--;
     32e:	8b 81       	ldd	r24, Y+3	; 0x03
     330:	9c 81       	ldd	r25, Y+4	; 0x04
     332:	01 97       	sbiw	r24, 0x01	; 1
     334:	9c 83       	std	Y+4, r25	; 0x04
     336:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     338:	8b 81       	ldd	r24, Y+3	; 0x03
     33a:	9c 81       	ldd	r25, Y+4	; 0x04
     33c:	25 e1       	ldi	r18, 0x15	; 21
     33e:	fc 01       	movw	r30, r24
     340:	20 83       	st	Z, r18
	pxTopOfStack--;
     342:	8b 81       	ldd	r24, Y+3	; 0x03
     344:	9c 81       	ldd	r25, Y+4	; 0x04
     346:	01 97       	sbiw	r24, 0x01	; 1
     348:	9c 83       	std	Y+4, r25	; 0x04
     34a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34c:	8b 81       	ldd	r24, Y+3	; 0x03
     34e:	9c 81       	ldd	r25, Y+4	; 0x04
     350:	26 e1       	ldi	r18, 0x16	; 22
     352:	fc 01       	movw	r30, r24
     354:	20 83       	st	Z, r18
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	8b 81       	ldd	r24, Y+3	; 0x03
     362:	9c 81       	ldd	r25, Y+4	; 0x04
     364:	27 e1       	ldi	r18, 0x17	; 23
     366:	fc 01       	movw	r30, r24
     368:	20 83       	st	Z, r18
	pxTopOfStack--;
     36a:	8b 81       	ldd	r24, Y+3	; 0x03
     36c:	9c 81       	ldd	r25, Y+4	; 0x04
     36e:	01 97       	sbiw	r24, 0x01	; 1
     370:	9c 83       	std	Y+4, r25	; 0x04
     372:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     374:	8b 81       	ldd	r24, Y+3	; 0x03
     376:	9c 81       	ldd	r25, Y+4	; 0x04
     378:	28 e1       	ldi	r18, 0x18	; 24
     37a:	fc 01       	movw	r30, r24
     37c:	20 83       	st	Z, r18
	pxTopOfStack--;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	01 97       	sbiw	r24, 0x01	; 1
     384:	9c 83       	std	Y+4, r25	; 0x04
     386:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     388:	8b 81       	ldd	r24, Y+3	; 0x03
     38a:	9c 81       	ldd	r25, Y+4	; 0x04
     38c:	29 e1       	ldi	r18, 0x19	; 25
     38e:	fc 01       	movw	r30, r24
     390:	20 83       	st	Z, r18
	pxTopOfStack--;
     392:	8b 81       	ldd	r24, Y+3	; 0x03
     394:	9c 81       	ldd	r25, Y+4	; 0x04
     396:	01 97       	sbiw	r24, 0x01	; 1
     398:	9c 83       	std	Y+4, r25	; 0x04
     39a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     39c:	8b 81       	ldd	r24, Y+3	; 0x03
     39e:	9c 81       	ldd	r25, Y+4	; 0x04
     3a0:	20 e2       	ldi	r18, 0x20	; 32
     3a2:	fc 01       	movw	r30, r24
     3a4:	20 83       	st	Z, r18
	pxTopOfStack--;
     3a6:	8b 81       	ldd	r24, Y+3	; 0x03
     3a8:	9c 81       	ldd	r25, Y+4	; 0x04
     3aa:	01 97       	sbiw	r24, 0x01	; 1
     3ac:	9c 83       	std	Y+4, r25	; 0x04
     3ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	21 e2       	ldi	r18, 0x21	; 33
     3b6:	fc 01       	movw	r30, r24
     3b8:	20 83       	st	Z, r18
	pxTopOfStack--;
     3ba:	8b 81       	ldd	r24, Y+3	; 0x03
     3bc:	9c 81       	ldd	r25, Y+4	; 0x04
     3be:	01 97       	sbiw	r24, 0x01	; 1
     3c0:	9c 83       	std	Y+4, r25	; 0x04
     3c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3c4:	8b 81       	ldd	r24, Y+3	; 0x03
     3c6:	9c 81       	ldd	r25, Y+4	; 0x04
     3c8:	22 e2       	ldi	r18, 0x22	; 34
     3ca:	fc 01       	movw	r30, r24
     3cc:	20 83       	st	Z, r18
	pxTopOfStack--;
     3ce:	8b 81       	ldd	r24, Y+3	; 0x03
     3d0:	9c 81       	ldd	r25, Y+4	; 0x04
     3d2:	01 97       	sbiw	r24, 0x01	; 1
     3d4:	9c 83       	std	Y+4, r25	; 0x04
     3d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3d8:	8b 81       	ldd	r24, Y+3	; 0x03
     3da:	9c 81       	ldd	r25, Y+4	; 0x04
     3dc:	23 e2       	ldi	r18, 0x23	; 35
     3de:	fc 01       	movw	r30, r24
     3e0:	20 83       	st	Z, r18
	pxTopOfStack--;
     3e2:	8b 81       	ldd	r24, Y+3	; 0x03
     3e4:	9c 81       	ldd	r25, Y+4	; 0x04
     3e6:	01 97       	sbiw	r24, 0x01	; 1
     3e8:	9c 83       	std	Y+4, r25	; 0x04
     3ea:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3ec:	8f 81       	ldd	r24, Y+7	; 0x07
     3ee:	98 85       	ldd	r25, Y+8	; 0x08
     3f0:	9a 83       	std	Y+2, r25	; 0x02
     3f2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3f4:	29 81       	ldd	r18, Y+1	; 0x01
     3f6:	8b 81       	ldd	r24, Y+3	; 0x03
     3f8:	9c 81       	ldd	r25, Y+4	; 0x04
     3fa:	fc 01       	movw	r30, r24
     3fc:	20 83       	st	Z, r18
	pxTopOfStack--;
     3fe:	8b 81       	ldd	r24, Y+3	; 0x03
     400:	9c 81       	ldd	r25, Y+4	; 0x04
     402:	01 97       	sbiw	r24, 0x01	; 1
     404:	9c 83       	std	Y+4, r25	; 0x04
     406:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     408:	89 81       	ldd	r24, Y+1	; 0x01
     40a:	9a 81       	ldd	r25, Y+2	; 0x02
     40c:	89 2f       	mov	r24, r25
     40e:	99 27       	eor	r25, r25
     410:	9a 83       	std	Y+2, r25	; 0x02
     412:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     414:	29 81       	ldd	r18, Y+1	; 0x01
     416:	8b 81       	ldd	r24, Y+3	; 0x03
     418:	9c 81       	ldd	r25, Y+4	; 0x04
     41a:	fc 01       	movw	r30, r24
     41c:	20 83       	st	Z, r18
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     428:	8b 81       	ldd	r24, Y+3	; 0x03
     42a:	9c 81       	ldd	r25, Y+4	; 0x04
     42c:	26 e2       	ldi	r18, 0x26	; 38
     42e:	fc 01       	movw	r30, r24
     430:	20 83       	st	Z, r18
	pxTopOfStack--;
     432:	8b 81       	ldd	r24, Y+3	; 0x03
     434:	9c 81       	ldd	r25, Y+4	; 0x04
     436:	01 97       	sbiw	r24, 0x01	; 1
     438:	9c 83       	std	Y+4, r25	; 0x04
     43a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     43c:	8b 81       	ldd	r24, Y+3	; 0x03
     43e:	9c 81       	ldd	r25, Y+4	; 0x04
     440:	27 e2       	ldi	r18, 0x27	; 39
     442:	fc 01       	movw	r30, r24
     444:	20 83       	st	Z, r18
	pxTopOfStack--;
     446:	8b 81       	ldd	r24, Y+3	; 0x03
     448:	9c 81       	ldd	r25, Y+4	; 0x04
     44a:	01 97       	sbiw	r24, 0x01	; 1
     44c:	9c 83       	std	Y+4, r25	; 0x04
     44e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     450:	8b 81       	ldd	r24, Y+3	; 0x03
     452:	9c 81       	ldd	r25, Y+4	; 0x04
     454:	28 e2       	ldi	r18, 0x28	; 40
     456:	fc 01       	movw	r30, r24
     458:	20 83       	st	Z, r18
	pxTopOfStack--;
     45a:	8b 81       	ldd	r24, Y+3	; 0x03
     45c:	9c 81       	ldd	r25, Y+4	; 0x04
     45e:	01 97       	sbiw	r24, 0x01	; 1
     460:	9c 83       	std	Y+4, r25	; 0x04
     462:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     464:	8b 81       	ldd	r24, Y+3	; 0x03
     466:	9c 81       	ldd	r25, Y+4	; 0x04
     468:	29 e2       	ldi	r18, 0x29	; 41
     46a:	fc 01       	movw	r30, r24
     46c:	20 83       	st	Z, r18
	pxTopOfStack--;
     46e:	8b 81       	ldd	r24, Y+3	; 0x03
     470:	9c 81       	ldd	r25, Y+4	; 0x04
     472:	01 97       	sbiw	r24, 0x01	; 1
     474:	9c 83       	std	Y+4, r25	; 0x04
     476:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	20 e3       	ldi	r18, 0x30	; 48
     47e:	fc 01       	movw	r30, r24
     480:	20 83       	st	Z, r18
	pxTopOfStack--;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
     486:	01 97       	sbiw	r24, 0x01	; 1
     488:	9c 83       	std	Y+4, r25	; 0x04
     48a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     48c:	8b 81       	ldd	r24, Y+3	; 0x03
     48e:	9c 81       	ldd	r25, Y+4	; 0x04
     490:	21 e3       	ldi	r18, 0x31	; 49
     492:	fc 01       	movw	r30, r24
     494:	20 83       	st	Z, r18
	pxTopOfStack--;
     496:	8b 81       	ldd	r24, Y+3	; 0x03
     498:	9c 81       	ldd	r25, Y+4	; 0x04
     49a:	01 97       	sbiw	r24, 0x01	; 1
     49c:	9c 83       	std	Y+4, r25	; 0x04
     49e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     4a0:	8b 81       	ldd	r24, Y+3	; 0x03
     4a2:	9c 81       	ldd	r25, Y+4	; 0x04
}
     4a4:	28 96       	adiw	r28, 0x08	; 8
     4a6:	0f b6       	in	r0, 0x3f	; 63
     4a8:	f8 94       	cli
     4aa:	de bf       	out	0x3e, r29	; 62
     4ac:	0f be       	out	0x3f, r0	; 63
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	df 91       	pop	r29
     4b2:	cf 91       	pop	r28
     4b4:	08 95       	ret

000004b6 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     4b6:	cf 93       	push	r28
     4b8:	df 93       	push	r29
     4ba:	cd b7       	in	r28, 0x3d	; 61
     4bc:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4be:	e4 d0       	rcall	.+456    	; 0x688 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4c0:	a0 91 ec 06 	lds	r26, 0x06EC	; 0x8006ec <pxCurrentTCB>
     4c4:	b0 91 ed 06 	lds	r27, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     4c8:	cd 91       	ld	r28, X+
     4ca:	cd bf       	out	0x3d, r28	; 61
     4cc:	dd 91       	ld	r29, X+
     4ce:	de bf       	out	0x3e, r29	; 62
     4d0:	ff 91       	pop	r31
     4d2:	ef 91       	pop	r30
     4d4:	df 91       	pop	r29
     4d6:	cf 91       	pop	r28
     4d8:	bf 91       	pop	r27
     4da:	af 91       	pop	r26
     4dc:	9f 91       	pop	r25
     4de:	8f 91       	pop	r24
     4e0:	7f 91       	pop	r23
     4e2:	6f 91       	pop	r22
     4e4:	5f 91       	pop	r21
     4e6:	4f 91       	pop	r20
     4e8:	3f 91       	pop	r19
     4ea:	2f 91       	pop	r18
     4ec:	1f 91       	pop	r17
     4ee:	0f 91       	pop	r16
     4f0:	ff 90       	pop	r15
     4f2:	ef 90       	pop	r14
     4f4:	df 90       	pop	r13
     4f6:	cf 90       	pop	r12
     4f8:	bf 90       	pop	r11
     4fa:	af 90       	pop	r10
     4fc:	9f 90       	pop	r9
     4fe:	8f 90       	pop	r8
     500:	7f 90       	pop	r7
     502:	6f 90       	pop	r6
     504:	5f 90       	pop	r5
     506:	4f 90       	pop	r4
     508:	3f 90       	pop	r3
     50a:	2f 90       	pop	r2
     50c:	1f 90       	pop	r1
     50e:	0f 90       	pop	r0
     510:	0f be       	out	0x3f, r0	; 63
     512:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     514:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     516:	81 e0       	ldi	r24, 0x01	; 1
}
     518:	df 91       	pop	r29
     51a:	cf 91       	pop	r28
     51c:	08 95       	ret

0000051e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     51e:	0f 92       	push	r0
     520:	0f b6       	in	r0, 0x3f	; 63
     522:	f8 94       	cli
     524:	0f 92       	push	r0
     526:	1f 92       	push	r1
     528:	11 24       	eor	r1, r1
     52a:	2f 92       	push	r2
     52c:	3f 92       	push	r3
     52e:	4f 92       	push	r4
     530:	5f 92       	push	r5
     532:	6f 92       	push	r6
     534:	7f 92       	push	r7
     536:	8f 92       	push	r8
     538:	9f 92       	push	r9
     53a:	af 92       	push	r10
     53c:	bf 92       	push	r11
     53e:	cf 92       	push	r12
     540:	df 92       	push	r13
     542:	ef 92       	push	r14
     544:	ff 92       	push	r15
     546:	0f 93       	push	r16
     548:	1f 93       	push	r17
     54a:	2f 93       	push	r18
     54c:	3f 93       	push	r19
     54e:	4f 93       	push	r20
     550:	5f 93       	push	r21
     552:	6f 93       	push	r22
     554:	7f 93       	push	r23
     556:	8f 93       	push	r24
     558:	9f 93       	push	r25
     55a:	af 93       	push	r26
     55c:	bf 93       	push	r27
     55e:	cf 93       	push	r28
     560:	df 93       	push	r29
     562:	ef 93       	push	r30
     564:	ff 93       	push	r31
     566:	a0 91 ec 06 	lds	r26, 0x06EC	; 0x8006ec <pxCurrentTCB>
     56a:	b0 91 ed 06 	lds	r27, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     56e:	0d b6       	in	r0, 0x3d	; 61
     570:	0d 92       	st	X+, r0
     572:	0e b6       	in	r0, 0x3e	; 62
     574:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     576:	6a d5       	rcall	.+2772   	; 0x104c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     578:	a0 91 ec 06 	lds	r26, 0x06EC	; 0x8006ec <pxCurrentTCB>
     57c:	b0 91 ed 06 	lds	r27, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     580:	cd 91       	ld	r28, X+
     582:	cd bf       	out	0x3d, r28	; 61
     584:	dd 91       	ld	r29, X+
     586:	de bf       	out	0x3e, r29	; 62
     588:	ff 91       	pop	r31
     58a:	ef 91       	pop	r30
     58c:	df 91       	pop	r29
     58e:	cf 91       	pop	r28
     590:	bf 91       	pop	r27
     592:	af 91       	pop	r26
     594:	9f 91       	pop	r25
     596:	8f 91       	pop	r24
     598:	7f 91       	pop	r23
     59a:	6f 91       	pop	r22
     59c:	5f 91       	pop	r21
     59e:	4f 91       	pop	r20
     5a0:	3f 91       	pop	r19
     5a2:	2f 91       	pop	r18
     5a4:	1f 91       	pop	r17
     5a6:	0f 91       	pop	r16
     5a8:	ff 90       	pop	r15
     5aa:	ef 90       	pop	r14
     5ac:	df 90       	pop	r13
     5ae:	cf 90       	pop	r12
     5b0:	bf 90       	pop	r11
     5b2:	af 90       	pop	r10
     5b4:	9f 90       	pop	r9
     5b6:	8f 90       	pop	r8
     5b8:	7f 90       	pop	r7
     5ba:	6f 90       	pop	r6
     5bc:	5f 90       	pop	r5
     5be:	4f 90       	pop	r4
     5c0:	3f 90       	pop	r3
     5c2:	2f 90       	pop	r2
     5c4:	1f 90       	pop	r1
     5c6:	0f 90       	pop	r0
     5c8:	0f be       	out	0x3f, r0	; 63
     5ca:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5cc:	08 95       	ret
	...

000005d0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5d0:	0f 92       	push	r0
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	0f 92       	push	r0
     5d8:	1f 92       	push	r1
     5da:	11 24       	eor	r1, r1
     5dc:	2f 92       	push	r2
     5de:	3f 92       	push	r3
     5e0:	4f 92       	push	r4
     5e2:	5f 92       	push	r5
     5e4:	6f 92       	push	r6
     5e6:	7f 92       	push	r7
     5e8:	8f 92       	push	r8
     5ea:	9f 92       	push	r9
     5ec:	af 92       	push	r10
     5ee:	bf 92       	push	r11
     5f0:	cf 92       	push	r12
     5f2:	df 92       	push	r13
     5f4:	ef 92       	push	r14
     5f6:	ff 92       	push	r15
     5f8:	0f 93       	push	r16
     5fa:	1f 93       	push	r17
     5fc:	2f 93       	push	r18
     5fe:	3f 93       	push	r19
     600:	4f 93       	push	r20
     602:	5f 93       	push	r21
     604:	6f 93       	push	r22
     606:	7f 93       	push	r23
     608:	8f 93       	push	r24
     60a:	9f 93       	push	r25
     60c:	af 93       	push	r26
     60e:	bf 93       	push	r27
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
     614:	ef 93       	push	r30
     616:	ff 93       	push	r31
     618:	a0 91 ec 06 	lds	r26, 0x06EC	; 0x8006ec <pxCurrentTCB>
     61c:	b0 91 ed 06 	lds	r27, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     620:	0d b6       	in	r0, 0x3d	; 61
     622:	0d 92       	st	X+, r0
     624:	0e b6       	in	r0, 0x3e	; 62
     626:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     628:	26 d4       	rcall	.+2124   	; 0xe76 <xTaskIncrementTick>
     62a:	88 23       	and	r24, r24
     62c:	09 f0       	breq	.+2      	; 0x630 <vPortYieldFromTick+0x60>
	{
		vTaskSwitchContext();
     62e:	0e d5       	rcall	.+2588   	; 0x104c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     630:	a0 91 ec 06 	lds	r26, 0x06EC	; 0x8006ec <pxCurrentTCB>
     634:	b0 91 ed 06 	lds	r27, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     638:	cd 91       	ld	r28, X+
     63a:	cd bf       	out	0x3d, r28	; 61
     63c:	dd 91       	ld	r29, X+
     63e:	de bf       	out	0x3e, r29	; 62
     640:	ff 91       	pop	r31
     642:	ef 91       	pop	r30
     644:	df 91       	pop	r29
     646:	cf 91       	pop	r28
     648:	bf 91       	pop	r27
     64a:	af 91       	pop	r26
     64c:	9f 91       	pop	r25
     64e:	8f 91       	pop	r24
     650:	7f 91       	pop	r23
     652:	6f 91       	pop	r22
     654:	5f 91       	pop	r21
     656:	4f 91       	pop	r20
     658:	3f 91       	pop	r19
     65a:	2f 91       	pop	r18
     65c:	1f 91       	pop	r17
     65e:	0f 91       	pop	r16
     660:	ff 90       	pop	r15
     662:	ef 90       	pop	r14
     664:	df 90       	pop	r13
     666:	cf 90       	pop	r12
     668:	bf 90       	pop	r11
     66a:	af 90       	pop	r10
     66c:	9f 90       	pop	r9
     66e:	8f 90       	pop	r8
     670:	7f 90       	pop	r7
     672:	6f 90       	pop	r6
     674:	5f 90       	pop	r5
     676:	4f 90       	pop	r4
     678:	3f 90       	pop	r3
     67a:	2f 90       	pop	r2
     67c:	1f 90       	pop	r1
     67e:	0f 90       	pop	r0
     680:	0f be       	out	0x3f, r0	; 63
     682:	0f 90       	pop	r0

	asm volatile ( "ret" );
     684:	08 95       	ret
	...

00000688 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     688:	cf 93       	push	r28
     68a:	df 93       	push	r29
     68c:	00 d0       	rcall	.+0      	; 0x68e <prvSetupTimerInterrupt+0x6>
     68e:	00 d0       	rcall	.+0      	; 0x690 <prvSetupTimerInterrupt+0x8>
     690:	1f 92       	push	r1
     692:	cd b7       	in	r28, 0x3d	; 61
     694:	de b7       	in	r29, 0x3e	; 62
	uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     696:	80 e8       	ldi	r24, 0x80	; 128
     698:	9e e3       	ldi	r25, 0x3E	; 62
     69a:	a0 e0       	ldi	r26, 0x00	; 0
     69c:	b0 e0       	ldi	r27, 0x00	; 0
     69e:	89 83       	std	Y+1, r24	; 0x01
     6a0:	9a 83       	std	Y+2, r25	; 0x02
     6a2:	ab 83       	std	Y+3, r26	; 0x03
     6a4:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     6a6:	89 81       	ldd	r24, Y+1	; 0x01
     6a8:	9a 81       	ldd	r25, Y+2	; 0x02
     6aa:	ab 81       	ldd	r26, Y+3	; 0x03
     6ac:	bc 81       	ldd	r27, Y+4	; 0x04
     6ae:	68 94       	set
     6b0:	15 f8       	bld	r1, 5
     6b2:	b6 95       	lsr	r27
     6b4:	a7 95       	ror	r26
     6b6:	97 95       	ror	r25
     6b8:	87 95       	ror	r24
     6ba:	16 94       	lsr	r1
     6bc:	d1 f7       	brne	.-12     	; 0x6b2 <prvSetupTimerInterrupt+0x2a>
     6be:	89 83       	std	Y+1, r24	; 0x01
     6c0:	9a 83       	std	Y+2, r25	; 0x02
     6c2:	ab 83       	std	Y+3, r26	; 0x03
     6c4:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6c6:	89 81       	ldd	r24, Y+1	; 0x01
     6c8:	9a 81       	ldd	r25, Y+2	; 0x02
     6ca:	ab 81       	ldd	r26, Y+3	; 0x03
     6cc:	bc 81       	ldd	r27, Y+4	; 0x04
     6ce:	01 97       	sbiw	r24, 0x01	; 1
     6d0:	a1 09       	sbc	r26, r1
     6d2:	b1 09       	sbc	r27, r1
     6d4:	89 83       	std	Y+1, r24	; 0x01
     6d6:	9a 83       	std	Y+2, r25	; 0x02
     6d8:	ab 83       	std	Y+3, r26	; 0x03
     6da:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	OCR1A = ulCompareMatch;
     6dc:	88 e8       	ldi	r24, 0x88	; 136
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	29 81       	ldd	r18, Y+1	; 0x01
     6e2:	3a 81       	ldd	r19, Y+2	; 0x02
     6e4:	fc 01       	movw	r30, r24
     6e6:	31 83       	std	Z+1, r19	; 0x01
     6e8:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));
     6ea:	80 e8       	ldi	r24, 0x80	; 128
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	20 e8       	ldi	r18, 0x80	; 128
     6f0:	30 e0       	ldi	r19, 0x00	; 0
     6f2:	f9 01       	movw	r30, r18
     6f4:	20 81       	ld	r18, Z
     6f6:	2c 7f       	andi	r18, 0xFC	; 252
     6f8:	fc 01       	movw	r30, r24
     6fa:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     6fc:	8b e0       	ldi	r24, 0x0B	; 11
     6fe:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
     700:	81 e8       	ldi	r24, 0x81	; 129
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	2d 81       	ldd	r18, Y+5	; 0x05
     706:	fc 01       	movw	r30, r24
     708:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     70a:	8f e6       	ldi	r24, 0x6F	; 111
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	fc 01       	movw	r30, r24
     710:	80 81       	ld	r24, Z
     712:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	8d 81       	ldd	r24, Y+5	; 0x05
     716:	82 60       	ori	r24, 0x02	; 2
     718:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK1 = ucLowByte;
     71a:	8f e6       	ldi	r24, 0x6F	; 111
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	2d 81       	ldd	r18, Y+5	; 0x05
     720:	fc 01       	movw	r30, r24
     722:	20 83       	st	Z, r18
}
     724:	00 00       	nop
     726:	0f 90       	pop	r0
     728:	0f 90       	pop	r0
     72a:	0f 90       	pop	r0
     72c:	0f 90       	pop	r0
     72e:	0f 90       	pop	r0
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	08 95       	ret

00000736 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     736:	4c df       	rcall	.-360    	; 0x5d0 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti
	...

0000073c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     73c:	cf 93       	push	r28
     73e:	df 93       	push	r29
     740:	00 d0       	rcall	.+0      	; 0x742 <vListInitialise+0x6>
     742:	cd b7       	in	r28, 0x3d	; 61
     744:	de b7       	in	r29, 0x3e	; 62
     746:	9a 83       	std	Y+2, r25	; 0x02
     748:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     74a:	89 81       	ldd	r24, Y+1	; 0x01
     74c:	9a 81       	ldd	r25, Y+2	; 0x02
     74e:	9c 01       	movw	r18, r24
     750:	2d 5f       	subi	r18, 0xFD	; 253
     752:	3f 4f       	sbci	r19, 0xFF	; 255
     754:	89 81       	ldd	r24, Y+1	; 0x01
     756:	9a 81       	ldd	r25, Y+2	; 0x02
     758:	fc 01       	movw	r30, r24
     75a:	32 83       	std	Z+2, r19	; 0x02
     75c:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     75e:	89 81       	ldd	r24, Y+1	; 0x01
     760:	9a 81       	ldd	r25, Y+2	; 0x02
     762:	2f ef       	ldi	r18, 0xFF	; 255
     764:	3f ef       	ldi	r19, 0xFF	; 255
     766:	fc 01       	movw	r30, r24
     768:	34 83       	std	Z+4, r19	; 0x04
     76a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     76c:	89 81       	ldd	r24, Y+1	; 0x01
     76e:	9a 81       	ldd	r25, Y+2	; 0x02
     770:	9c 01       	movw	r18, r24
     772:	2d 5f       	subi	r18, 0xFD	; 253
     774:	3f 4f       	sbci	r19, 0xFF	; 255
     776:	89 81       	ldd	r24, Y+1	; 0x01
     778:	9a 81       	ldd	r25, Y+2	; 0x02
     77a:	fc 01       	movw	r30, r24
     77c:	36 83       	std	Z+6, r19	; 0x06
     77e:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     780:	89 81       	ldd	r24, Y+1	; 0x01
     782:	9a 81       	ldd	r25, Y+2	; 0x02
     784:	9c 01       	movw	r18, r24
     786:	2d 5f       	subi	r18, 0xFD	; 253
     788:	3f 4f       	sbci	r19, 0xFF	; 255
     78a:	89 81       	ldd	r24, Y+1	; 0x01
     78c:	9a 81       	ldd	r25, Y+2	; 0x02
     78e:	fc 01       	movw	r30, r24
     790:	30 87       	std	Z+8, r19	; 0x08
     792:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     794:	89 81       	ldd	r24, Y+1	; 0x01
     796:	9a 81       	ldd	r25, Y+2	; 0x02
     798:	fc 01       	movw	r30, r24
     79a:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     79c:	00 00       	nop
     79e:	0f 90       	pop	r0
     7a0:	0f 90       	pop	r0
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	08 95       	ret

000007a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <vListInitialiseItem+0x6>
     7ae:	cd b7       	in	r28, 0x3d	; 61
     7b0:	de b7       	in	r29, 0x3e	; 62
     7b2:	9a 83       	std	Y+2, r25	; 0x02
     7b4:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	9a 81       	ldd	r25, Y+2	; 0x02
     7ba:	fc 01       	movw	r30, r24
     7bc:	11 86       	std	Z+9, r1	; 0x09
     7be:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     7c0:	00 00       	nop
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	08 95       	ret

000007cc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     7cc:	cf 93       	push	r28
     7ce:	df 93       	push	r29
     7d0:	00 d0       	rcall	.+0      	; 0x7d2 <vListInsertEnd+0x6>
     7d2:	00 d0       	rcall	.+0      	; 0x7d4 <vListInsertEnd+0x8>
     7d4:	00 d0       	rcall	.+0      	; 0x7d6 <vListInsertEnd+0xa>
     7d6:	cd b7       	in	r28, 0x3d	; 61
     7d8:	de b7       	in	r29, 0x3e	; 62
     7da:	9c 83       	std	Y+4, r25	; 0x04
     7dc:	8b 83       	std	Y+3, r24	; 0x03
     7de:	7e 83       	std	Y+6, r23	; 0x06
     7e0:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     7e2:	8b 81       	ldd	r24, Y+3	; 0x03
     7e4:	9c 81       	ldd	r25, Y+4	; 0x04
     7e6:	fc 01       	movw	r30, r24
     7e8:	81 81       	ldd	r24, Z+1	; 0x01
     7ea:	92 81       	ldd	r25, Z+2	; 0x02
     7ec:	9a 83       	std	Y+2, r25	; 0x02
     7ee:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     7f0:	8d 81       	ldd	r24, Y+5	; 0x05
     7f2:	9e 81       	ldd	r25, Y+6	; 0x06
     7f4:	29 81       	ldd	r18, Y+1	; 0x01
     7f6:	3a 81       	ldd	r19, Y+2	; 0x02
     7f8:	fc 01       	movw	r30, r24
     7fa:	33 83       	std	Z+3, r19	; 0x03
     7fc:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     7fe:	89 81       	ldd	r24, Y+1	; 0x01
     800:	9a 81       	ldd	r25, Y+2	; 0x02
     802:	fc 01       	movw	r30, r24
     804:	24 81       	ldd	r18, Z+4	; 0x04
     806:	35 81       	ldd	r19, Z+5	; 0x05
     808:	8d 81       	ldd	r24, Y+5	; 0x05
     80a:	9e 81       	ldd	r25, Y+6	; 0x06
     80c:	fc 01       	movw	r30, r24
     80e:	35 83       	std	Z+5, r19	; 0x05
     810:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     812:	89 81       	ldd	r24, Y+1	; 0x01
     814:	9a 81       	ldd	r25, Y+2	; 0x02
     816:	fc 01       	movw	r30, r24
     818:	84 81       	ldd	r24, Z+4	; 0x04
     81a:	95 81       	ldd	r25, Z+5	; 0x05
     81c:	2d 81       	ldd	r18, Y+5	; 0x05
     81e:	3e 81       	ldd	r19, Y+6	; 0x06
     820:	fc 01       	movw	r30, r24
     822:	33 83       	std	Z+3, r19	; 0x03
     824:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     826:	89 81       	ldd	r24, Y+1	; 0x01
     828:	9a 81       	ldd	r25, Y+2	; 0x02
     82a:	2d 81       	ldd	r18, Y+5	; 0x05
     82c:	3e 81       	ldd	r19, Y+6	; 0x06
     82e:	fc 01       	movw	r30, r24
     830:	35 83       	std	Z+5, r19	; 0x05
     832:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     834:	8d 81       	ldd	r24, Y+5	; 0x05
     836:	9e 81       	ldd	r25, Y+6	; 0x06
     838:	2b 81       	ldd	r18, Y+3	; 0x03
     83a:	3c 81       	ldd	r19, Y+4	; 0x04
     83c:	fc 01       	movw	r30, r24
     83e:	31 87       	std	Z+9, r19	; 0x09
     840:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     842:	8b 81       	ldd	r24, Y+3	; 0x03
     844:	9c 81       	ldd	r25, Y+4	; 0x04
     846:	fc 01       	movw	r30, r24
     848:	80 81       	ld	r24, Z
     84a:	21 e0       	ldi	r18, 0x01	; 1
     84c:	28 0f       	add	r18, r24
     84e:	8b 81       	ldd	r24, Y+3	; 0x03
     850:	9c 81       	ldd	r25, Y+4	; 0x04
     852:	fc 01       	movw	r30, r24
     854:	20 83       	st	Z, r18
}
     856:	00 00       	nop
     858:	26 96       	adiw	r28, 0x06	; 6
     85a:	0f b6       	in	r0, 0x3f	; 63
     85c:	f8 94       	cli
     85e:	de bf       	out	0x3e, r29	; 62
     860:	0f be       	out	0x3f, r0	; 63
     862:	cd bf       	out	0x3d, r28	; 61
     864:	df 91       	pop	r29
     866:	cf 91       	pop	r28
     868:	08 95       	ret

0000086a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     86a:	cf 93       	push	r28
     86c:	df 93       	push	r29
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	28 97       	sbiw	r28, 0x08	; 8
     874:	0f b6       	in	r0, 0x3f	; 63
     876:	f8 94       	cli
     878:	de bf       	out	0x3e, r29	; 62
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	9e 83       	std	Y+6, r25	; 0x06
     880:	8d 83       	std	Y+5, r24	; 0x05
     882:	78 87       	std	Y+8, r23	; 0x08
     884:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     886:	8f 81       	ldd	r24, Y+7	; 0x07
     888:	98 85       	ldd	r25, Y+8	; 0x08
     88a:	fc 01       	movw	r30, r24
     88c:	80 81       	ld	r24, Z
     88e:	91 81       	ldd	r25, Z+1	; 0x01
     890:	9c 83       	std	Y+4, r25	; 0x04
     892:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     894:	8b 81       	ldd	r24, Y+3	; 0x03
     896:	9c 81       	ldd	r25, Y+4	; 0x04
     898:	01 96       	adiw	r24, 0x01	; 1
     89a:	41 f4       	brne	.+16     	; 0x8ac <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     89c:	8d 81       	ldd	r24, Y+5	; 0x05
     89e:	9e 81       	ldd	r25, Y+6	; 0x06
     8a0:	fc 01       	movw	r30, r24
     8a2:	87 81       	ldd	r24, Z+7	; 0x07
     8a4:	90 85       	ldd	r25, Z+8	; 0x08
     8a6:	9a 83       	std	Y+2, r25	; 0x02
     8a8:	89 83       	std	Y+1, r24	; 0x01
     8aa:	1a c0       	rjmp	.+52     	; 0x8e0 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ac:	8d 81       	ldd	r24, Y+5	; 0x05
     8ae:	9e 81       	ldd	r25, Y+6	; 0x06
     8b0:	03 96       	adiw	r24, 0x03	; 3
     8b2:	9a 83       	std	Y+2, r25	; 0x02
     8b4:	89 83       	std	Y+1, r24	; 0x01
     8b6:	07 c0       	rjmp	.+14     	; 0x8c6 <vListInsert+0x5c>
     8b8:	89 81       	ldd	r24, Y+1	; 0x01
     8ba:	9a 81       	ldd	r25, Y+2	; 0x02
     8bc:	fc 01       	movw	r30, r24
     8be:	82 81       	ldd	r24, Z+2	; 0x02
     8c0:	93 81       	ldd	r25, Z+3	; 0x03
     8c2:	9a 83       	std	Y+2, r25	; 0x02
     8c4:	89 83       	std	Y+1, r24	; 0x01
     8c6:	89 81       	ldd	r24, Y+1	; 0x01
     8c8:	9a 81       	ldd	r25, Y+2	; 0x02
     8ca:	fc 01       	movw	r30, r24
     8cc:	82 81       	ldd	r24, Z+2	; 0x02
     8ce:	93 81       	ldd	r25, Z+3	; 0x03
     8d0:	fc 01       	movw	r30, r24
     8d2:	20 81       	ld	r18, Z
     8d4:	31 81       	ldd	r19, Z+1	; 0x01
     8d6:	8b 81       	ldd	r24, Y+3	; 0x03
     8d8:	9c 81       	ldd	r25, Y+4	; 0x04
     8da:	82 17       	cp	r24, r18
     8dc:	93 07       	cpc	r25, r19
     8de:	60 f7       	brcc	.-40     	; 0x8b8 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8e0:	89 81       	ldd	r24, Y+1	; 0x01
     8e2:	9a 81       	ldd	r25, Y+2	; 0x02
     8e4:	fc 01       	movw	r30, r24
     8e6:	22 81       	ldd	r18, Z+2	; 0x02
     8e8:	33 81       	ldd	r19, Z+3	; 0x03
     8ea:	8f 81       	ldd	r24, Y+7	; 0x07
     8ec:	98 85       	ldd	r25, Y+8	; 0x08
     8ee:	fc 01       	movw	r30, r24
     8f0:	33 83       	std	Z+3, r19	; 0x03
     8f2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8f4:	8f 81       	ldd	r24, Y+7	; 0x07
     8f6:	98 85       	ldd	r25, Y+8	; 0x08
     8f8:	fc 01       	movw	r30, r24
     8fa:	82 81       	ldd	r24, Z+2	; 0x02
     8fc:	93 81       	ldd	r25, Z+3	; 0x03
     8fe:	2f 81       	ldd	r18, Y+7	; 0x07
     900:	38 85       	ldd	r19, Y+8	; 0x08
     902:	fc 01       	movw	r30, r24
     904:	35 83       	std	Z+5, r19	; 0x05
     906:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     908:	8f 81       	ldd	r24, Y+7	; 0x07
     90a:	98 85       	ldd	r25, Y+8	; 0x08
     90c:	29 81       	ldd	r18, Y+1	; 0x01
     90e:	3a 81       	ldd	r19, Y+2	; 0x02
     910:	fc 01       	movw	r30, r24
     912:	35 83       	std	Z+5, r19	; 0x05
     914:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     916:	89 81       	ldd	r24, Y+1	; 0x01
     918:	9a 81       	ldd	r25, Y+2	; 0x02
     91a:	2f 81       	ldd	r18, Y+7	; 0x07
     91c:	38 85       	ldd	r19, Y+8	; 0x08
     91e:	fc 01       	movw	r30, r24
     920:	33 83       	std	Z+3, r19	; 0x03
     922:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     924:	8f 81       	ldd	r24, Y+7	; 0x07
     926:	98 85       	ldd	r25, Y+8	; 0x08
     928:	2d 81       	ldd	r18, Y+5	; 0x05
     92a:	3e 81       	ldd	r19, Y+6	; 0x06
     92c:	fc 01       	movw	r30, r24
     92e:	31 87       	std	Z+9, r19	; 0x09
     930:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     932:	8d 81       	ldd	r24, Y+5	; 0x05
     934:	9e 81       	ldd	r25, Y+6	; 0x06
     936:	fc 01       	movw	r30, r24
     938:	80 81       	ld	r24, Z
     93a:	21 e0       	ldi	r18, 0x01	; 1
     93c:	28 0f       	add	r18, r24
     93e:	8d 81       	ldd	r24, Y+5	; 0x05
     940:	9e 81       	ldd	r25, Y+6	; 0x06
     942:	fc 01       	movw	r30, r24
     944:	20 83       	st	Z, r18
}
     946:	00 00       	nop
     948:	28 96       	adiw	r28, 0x08	; 8
     94a:	0f b6       	in	r0, 0x3f	; 63
     94c:	f8 94       	cli
     94e:	de bf       	out	0x3e, r29	; 62
     950:	0f be       	out	0x3f, r0	; 63
     952:	cd bf       	out	0x3d, r28	; 61
     954:	df 91       	pop	r29
     956:	cf 91       	pop	r28
     958:	08 95       	ret

0000095a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     95a:	cf 93       	push	r28
     95c:	df 93       	push	r29
     95e:	00 d0       	rcall	.+0      	; 0x960 <uxListRemove+0x6>
     960:	00 d0       	rcall	.+0      	; 0x962 <uxListRemove+0x8>
     962:	cd b7       	in	r28, 0x3d	; 61
     964:	de b7       	in	r29, 0x3e	; 62
     966:	9c 83       	std	Y+4, r25	; 0x04
     968:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     96a:	8b 81       	ldd	r24, Y+3	; 0x03
     96c:	9c 81       	ldd	r25, Y+4	; 0x04
     96e:	fc 01       	movw	r30, r24
     970:	80 85       	ldd	r24, Z+8	; 0x08
     972:	91 85       	ldd	r25, Z+9	; 0x09
     974:	9a 83       	std	Y+2, r25	; 0x02
     976:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     978:	8b 81       	ldd	r24, Y+3	; 0x03
     97a:	9c 81       	ldd	r25, Y+4	; 0x04
     97c:	fc 01       	movw	r30, r24
     97e:	82 81       	ldd	r24, Z+2	; 0x02
     980:	93 81       	ldd	r25, Z+3	; 0x03
     982:	2b 81       	ldd	r18, Y+3	; 0x03
     984:	3c 81       	ldd	r19, Y+4	; 0x04
     986:	f9 01       	movw	r30, r18
     988:	24 81       	ldd	r18, Z+4	; 0x04
     98a:	35 81       	ldd	r19, Z+5	; 0x05
     98c:	fc 01       	movw	r30, r24
     98e:	35 83       	std	Z+5, r19	; 0x05
     990:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     992:	8b 81       	ldd	r24, Y+3	; 0x03
     994:	9c 81       	ldd	r25, Y+4	; 0x04
     996:	fc 01       	movw	r30, r24
     998:	84 81       	ldd	r24, Z+4	; 0x04
     99a:	95 81       	ldd	r25, Z+5	; 0x05
     99c:	2b 81       	ldd	r18, Y+3	; 0x03
     99e:	3c 81       	ldd	r19, Y+4	; 0x04
     9a0:	f9 01       	movw	r30, r18
     9a2:	22 81       	ldd	r18, Z+2	; 0x02
     9a4:	33 81       	ldd	r19, Z+3	; 0x03
     9a6:	fc 01       	movw	r30, r24
     9a8:	33 83       	std	Z+3, r19	; 0x03
     9aa:	22 83       	std	Z+2, r18	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9ac:	89 81       	ldd	r24, Y+1	; 0x01
     9ae:	9a 81       	ldd	r25, Y+2	; 0x02
     9b0:	fc 01       	movw	r30, r24
     9b2:	21 81       	ldd	r18, Z+1	; 0x01
     9b4:	32 81       	ldd	r19, Z+2	; 0x02
     9b6:	8b 81       	ldd	r24, Y+3	; 0x03
     9b8:	9c 81       	ldd	r25, Y+4	; 0x04
     9ba:	28 17       	cp	r18, r24
     9bc:	39 07       	cpc	r19, r25
     9be:	51 f4       	brne	.+20     	; 0x9d4 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9c0:	8b 81       	ldd	r24, Y+3	; 0x03
     9c2:	9c 81       	ldd	r25, Y+4	; 0x04
     9c4:	fc 01       	movw	r30, r24
     9c6:	24 81       	ldd	r18, Z+4	; 0x04
     9c8:	35 81       	ldd	r19, Z+5	; 0x05
     9ca:	89 81       	ldd	r24, Y+1	; 0x01
     9cc:	9a 81       	ldd	r25, Y+2	; 0x02
     9ce:	fc 01       	movw	r30, r24
     9d0:	32 83       	std	Z+2, r19	; 0x02
     9d2:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9d4:	8b 81       	ldd	r24, Y+3	; 0x03
     9d6:	9c 81       	ldd	r25, Y+4	; 0x04
     9d8:	fc 01       	movw	r30, r24
     9da:	11 86       	std	Z+9, r1	; 0x09
     9dc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9de:	89 81       	ldd	r24, Y+1	; 0x01
     9e0:	9a 81       	ldd	r25, Y+2	; 0x02
     9e2:	fc 01       	movw	r30, r24
     9e4:	80 81       	ld	r24, Z
     9e6:	2f ef       	ldi	r18, 0xFF	; 255
     9e8:	28 0f       	add	r18, r24
     9ea:	89 81       	ldd	r24, Y+1	; 0x01
     9ec:	9a 81       	ldd	r25, Y+2	; 0x02
     9ee:	fc 01       	movw	r30, r24
     9f0:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	9a 81       	ldd	r25, Y+2	; 0x02
     9f6:	fc 01       	movw	r30, r24
     9f8:	80 81       	ld	r24, Z
}
     9fa:	0f 90       	pop	r0
     9fc:	0f 90       	pop	r0
     9fe:	0f 90       	pop	r0
     a00:	0f 90       	pop	r0
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	08 95       	ret

00000a08 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     a08:	af 92       	push	r10
     a0a:	bf 92       	push	r11
     a0c:	cf 92       	push	r12
     a0e:	df 92       	push	r13
     a10:	ef 92       	push	r14
     a12:	ff 92       	push	r15
     a14:	0f 93       	push	r16
     a16:	1f 93       	push	r17
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	cd b7       	in	r28, 0x3d	; 61
     a1e:	de b7       	in	r29, 0x3e	; 62
     a20:	64 97       	sbiw	r28, 0x14	; 20
     a22:	0f b6       	in	r0, 0x3f	; 63
     a24:	f8 94       	cli
     a26:	de bf       	out	0x3e, r29	; 62
     a28:	0f be       	out	0x3f, r0	; 63
     a2a:	cd bf       	out	0x3d, r28	; 61
     a2c:	9f 83       	std	Y+7, r25	; 0x07
     a2e:	8e 83       	std	Y+6, r24	; 0x06
     a30:	79 87       	std	Y+9, r23	; 0x09
     a32:	68 87       	std	Y+8, r22	; 0x08
     a34:	5b 87       	std	Y+11, r21	; 0x0b
     a36:	4a 87       	std	Y+10, r20	; 0x0a
     a38:	3d 87       	std	Y+13, r19	; 0x0d
     a3a:	2c 87       	std	Y+12, r18	; 0x0c
     a3c:	0e 87       	std	Y+14, r16	; 0x0e
     a3e:	f8 8a       	std	Y+16, r15	; 0x10
     a40:	ef 86       	std	Y+15, r14	; 0x0f
     a42:	da 8a       	std	Y+18, r13	; 0x12
     a44:	c9 8a       	std	Y+17, r12	; 0x11
     a46:	bc 8a       	std	Y+20, r11	; 0x14
     a48:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     a4a:	29 89       	ldd	r18, Y+17	; 0x11
     a4c:	3a 89       	ldd	r19, Y+18	; 0x12
     a4e:	8a 85       	ldd	r24, Y+10	; 0x0a
     a50:	9b 85       	ldd	r25, Y+11	; 0x0b
     a52:	b9 01       	movw	r22, r18
     a54:	bd d4       	rcall	.+2426   	; 0x13d0 <prvAllocateTCBAndStack>
     a56:	9b 83       	std	Y+3, r25	; 0x03
     a58:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     a5a:	8a 81       	ldd	r24, Y+2	; 0x02
     a5c:	9b 81       	ldd	r25, Y+3	; 0x03
     a5e:	89 2b       	or	r24, r25
     a60:	09 f4       	brne	.+2      	; 0xa64 <xTaskGenericCreate+0x5c>
     a62:	8d c0       	rjmp	.+282    	; 0xb7e <xTaskGenericCreate+0x176>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     a64:	8a 81       	ldd	r24, Y+2	; 0x02
     a66:	9b 81       	ldd	r25, Y+3	; 0x03
     a68:	fc 01       	movw	r30, r24
     a6a:	27 89       	ldd	r18, Z+23	; 0x17
     a6c:	30 8d       	ldd	r19, Z+24	; 0x18
     a6e:	8a 85       	ldd	r24, Y+10	; 0x0a
     a70:	9b 85       	ldd	r25, Y+11	; 0x0b
     a72:	01 97       	sbiw	r24, 0x01	; 1
     a74:	82 0f       	add	r24, r18
     a76:	93 1f       	adc	r25, r19
     a78:	9d 83       	std	Y+5, r25	; 0x05
     a7a:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     a7c:	4a 85       	ldd	r20, Y+10	; 0x0a
     a7e:	5b 85       	ldd	r21, Y+11	; 0x0b
     a80:	2b 89       	ldd	r18, Y+19	; 0x13
     a82:	3c 89       	ldd	r19, Y+20	; 0x14
     a84:	68 85       	ldd	r22, Y+8	; 0x08
     a86:	79 85       	ldd	r23, Y+9	; 0x09
     a88:	8a 81       	ldd	r24, Y+2	; 0x02
     a8a:	9b 81       	ldd	r25, Y+3	; 0x03
     a8c:	8a 01       	movw	r16, r20
     a8e:	4e 85       	ldd	r20, Y+14	; 0x0e
     a90:	5c d3       	rcall	.+1720   	; 0x114a <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     a92:	4c 85       	ldd	r20, Y+12	; 0x0c
     a94:	5d 85       	ldd	r21, Y+13	; 0x0d
     a96:	2e 81       	ldd	r18, Y+6	; 0x06
     a98:	3f 81       	ldd	r19, Y+7	; 0x07
     a9a:	8c 81       	ldd	r24, Y+4	; 0x04
     a9c:	9d 81       	ldd	r25, Y+5	; 0x05
     a9e:	b9 01       	movw	r22, r18
     aa0:	61 db       	rcall	.-2366   	; 0x164 <pxPortInitialiseStack>
     aa2:	9c 01       	movw	r18, r24
     aa4:	8a 81       	ldd	r24, Y+2	; 0x02
     aa6:	9b 81       	ldd	r25, Y+3	; 0x03
     aa8:	fc 01       	movw	r30, r24
     aaa:	31 83       	std	Z+1, r19	; 0x01
     aac:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     aae:	8f 85       	ldd	r24, Y+15	; 0x0f
     ab0:	98 89       	ldd	r25, Y+16	; 0x10
     ab2:	89 2b       	or	r24, r25
     ab4:	39 f0       	breq	.+14     	; 0xac4 <xTaskGenericCreate+0xbc>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     ab6:	8f 85       	ldd	r24, Y+15	; 0x0f
     ab8:	98 89       	ldd	r25, Y+16	; 0x10
     aba:	2a 81       	ldd	r18, Y+2	; 0x02
     abc:	3b 81       	ldd	r19, Y+3	; 0x03
     abe:	fc 01       	movw	r30, r24
     ac0:	31 83       	std	Z+1, r19	; 0x01
     ac2:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     ac4:	0f b6       	in	r0, 0x3f	; 63
     ac6:	f8 94       	cli
     ac8:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     aca:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxCurrentNumberOfTasks>
     ace:	8f 5f       	subi	r24, 0xFF	; 255
     ad0:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <uxCurrentNumberOfTasks>
			if( pxCurrentTCB == NULL )
     ad4:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
     ad8:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     adc:	89 2b       	or	r24, r25
     ade:	61 f4       	brne	.+24     	; 0xaf8 <xTaskGenericCreate+0xf0>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     ae0:	8a 81       	ldd	r24, Y+2	; 0x02
     ae2:	9b 81       	ldd	r25, Y+3	; 0x03
     ae4:	90 93 ed 06 	sts	0x06ED, r25	; 0x8006ed <pxCurrentTCB+0x1>
     ae8:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <pxCurrentTCB>

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     aec:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxCurrentNumberOfTasks>
     af0:	81 30       	cpi	r24, 0x01	; 1
     af2:	a9 f4       	brne	.+42     	; 0xb1e <xTaskGenericCreate+0x116>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     af4:	ae d3       	rcall	.+1884   	; 0x1252 <prvInitialiseTaskLists>
     af6:	13 c0       	rjmp	.+38     	; 0xb1e <xTaskGenericCreate+0x116>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     af8:	80 91 3f 07 	lds	r24, 0x073F	; 0x80073f <xSchedulerRunning>
     afc:	88 23       	and	r24, r24
     afe:	79 f4       	brne	.+30     	; 0xb1e <xTaskGenericCreate+0x116>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     b00:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
     b04:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     b08:	fc 01       	movw	r30, r24
     b0a:	96 89       	ldd	r25, Z+22	; 0x16
     b0c:	8e 85       	ldd	r24, Y+14	; 0x0e
     b0e:	89 17       	cp	r24, r25
     b10:	30 f0       	brcs	.+12     	; 0xb1e <xTaskGenericCreate+0x116>
					{
						pxCurrentTCB = pxNewTCB;
     b12:	8a 81       	ldd	r24, Y+2	; 0x02
     b14:	9b 81       	ldd	r25, Y+3	; 0x03
     b16:	90 93 ed 06 	sts	0x06ED, r25	; 0x8006ed <pxCurrentTCB+0x1>
     b1a:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <pxCurrentTCB>
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     b1e:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxTaskNumber>
     b22:	8f 5f       	subi	r24, 0xFF	; 255
     b24:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <uxTaskNumber>
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     b28:	8a 81       	ldd	r24, Y+2	; 0x02
     b2a:	9b 81       	ldd	r25, Y+3	; 0x03
     b2c:	fc 01       	movw	r30, r24
     b2e:	96 89       	ldd	r25, Z+22	; 0x16
     b30:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
     b34:	89 17       	cp	r24, r25
     b36:	30 f4       	brcc	.+12     	; 0xb44 <xTaskGenericCreate+0x13c>
     b38:	8a 81       	ldd	r24, Y+2	; 0x02
     b3a:	9b 81       	ldd	r25, Y+3	; 0x03
     b3c:	fc 01       	movw	r30, r24
     b3e:	86 89       	ldd	r24, Z+22	; 0x16
     b40:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <uxTopReadyPriority>
     b44:	8a 81       	ldd	r24, Y+2	; 0x02
     b46:	9b 81       	ldd	r25, Y+3	; 0x03
     b48:	ac 01       	movw	r20, r24
     b4a:	4e 5f       	subi	r20, 0xFE	; 254
     b4c:	5f 4f       	sbci	r21, 0xFF	; 255
     b4e:	8a 81       	ldd	r24, Y+2	; 0x02
     b50:	9b 81       	ldd	r25, Y+3	; 0x03
     b52:	fc 01       	movw	r30, r24
     b54:	86 89       	ldd	r24, Z+22	; 0x16
     b56:	28 2f       	mov	r18, r24
     b58:	30 e0       	ldi	r19, 0x00	; 0
     b5a:	c9 01       	movw	r24, r18
     b5c:	88 0f       	add	r24, r24
     b5e:	99 1f       	adc	r25, r25
     b60:	88 0f       	add	r24, r24
     b62:	99 1f       	adc	r25, r25
     b64:	88 0f       	add	r24, r24
     b66:	99 1f       	adc	r25, r25
     b68:	82 0f       	add	r24, r18
     b6a:	93 1f       	adc	r25, r19
     b6c:	82 51       	subi	r24, 0x12	; 18
     b6e:	99 4f       	sbci	r25, 0xF9	; 249
     b70:	ba 01       	movw	r22, r20
     b72:	2c de       	rcall	.-936    	; 0x7cc <vListInsertEnd>

			xReturn = pdPASS;
     b74:	81 e0       	ldi	r24, 0x01	; 1
     b76:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     b78:	0f 90       	pop	r0
     b7a:	0f be       	out	0x3f, r0	; 63
     b7c:	02 c0       	rjmp	.+4      	; 0xb82 <xTaskGenericCreate+0x17a>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     b82:	89 81       	ldd	r24, Y+1	; 0x01
     b84:	81 30       	cpi	r24, 0x01	; 1
     b86:	71 f4       	brne	.+28     	; 0xba4 <xTaskGenericCreate+0x19c>
	{
		if( xSchedulerRunning != pdFALSE )
     b88:	80 91 3f 07 	lds	r24, 0x073F	; 0x80073f <xSchedulerRunning>
     b8c:	88 23       	and	r24, r24
     b8e:	51 f0       	breq	.+20     	; 0xba4 <xTaskGenericCreate+0x19c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     b90:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
     b94:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     b98:	fc 01       	movw	r30, r24
     b9a:	96 89       	ldd	r25, Z+22	; 0x16
     b9c:	8e 85       	ldd	r24, Y+14	; 0x0e
     b9e:	98 17       	cp	r25, r24
     ba0:	08 f4       	brcc	.+2      	; 0xba4 <xTaskGenericCreate+0x19c>
			{
				taskYIELD_IF_USING_PREEMPTION();
     ba2:	bd dc       	rcall	.-1670   	; 0x51e <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
     ba4:	89 81       	ldd	r24, Y+1	; 0x01
}
     ba6:	64 96       	adiw	r28, 0x14	; 20
     ba8:	0f b6       	in	r0, 0x3f	; 63
     baa:	f8 94       	cli
     bac:	de bf       	out	0x3e, r29	; 62
     bae:	0f be       	out	0x3f, r0	; 63
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	df 91       	pop	r29
     bb4:	cf 91       	pop	r28
     bb6:	1f 91       	pop	r17
     bb8:	0f 91       	pop	r16
     bba:	ff 90       	pop	r15
     bbc:	ef 90       	pop	r14
     bbe:	df 90       	pop	r13
     bc0:	cf 90       	pop	r12
     bc2:	bf 90       	pop	r11
     bc4:	af 90       	pop	r10
     bc6:	08 95       	ret

00000bc8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	cd b7       	in	r28, 0x3d	; 61
     bce:	de b7       	in	r29, 0x3e	; 62
     bd0:	2a 97       	sbiw	r28, 0x0a	; 10
     bd2:	0f b6       	in	r0, 0x3f	; 63
     bd4:	f8 94       	cli
     bd6:	de bf       	out	0x3e, r29	; 62
     bd8:	0f be       	out	0x3f, r0	; 63
     bda:	cd bf       	out	0x3d, r28	; 61
     bdc:	98 87       	std	Y+8, r25	; 0x08
     bde:	8f 83       	std	Y+7, r24	; 0x07
     be0:	7a 87       	std	Y+10, r23	; 0x0a
     be2:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     be4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     be6:	9a d0       	rcall	.+308    	; 0xd1c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     be8:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <xTickCount>
     bec:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <xTickCount+0x1>
     bf0:	9b 83       	std	Y+3, r25	; 0x03
     bf2:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     bf4:	8f 81       	ldd	r24, Y+7	; 0x07
     bf6:	98 85       	ldd	r25, Y+8	; 0x08
     bf8:	fc 01       	movw	r30, r24
     bfa:	20 81       	ld	r18, Z
     bfc:	31 81       	ldd	r19, Z+1	; 0x01
     bfe:	89 85       	ldd	r24, Y+9	; 0x09
     c00:	9a 85       	ldd	r25, Y+10	; 0x0a
     c02:	82 0f       	add	r24, r18
     c04:	93 1f       	adc	r25, r19
     c06:	9d 83       	std	Y+5, r25	; 0x05
     c08:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
     c0a:	8f 81       	ldd	r24, Y+7	; 0x07
     c0c:	98 85       	ldd	r25, Y+8	; 0x08
     c0e:	fc 01       	movw	r30, r24
     c10:	20 81       	ld	r18, Z
     c12:	31 81       	ldd	r19, Z+1	; 0x01
     c14:	8a 81       	ldd	r24, Y+2	; 0x02
     c16:	9b 81       	ldd	r25, Y+3	; 0x03
     c18:	82 17       	cp	r24, r18
     c1a:	93 07       	cpc	r25, r19
     c1c:	a0 f4       	brcc	.+40     	; 0xc46 <vTaskDelayUntil+0x7e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     c1e:	8f 81       	ldd	r24, Y+7	; 0x07
     c20:	98 85       	ldd	r25, Y+8	; 0x08
     c22:	fc 01       	movw	r30, r24
     c24:	20 81       	ld	r18, Z
     c26:	31 81       	ldd	r19, Z+1	; 0x01
     c28:	8c 81       	ldd	r24, Y+4	; 0x04
     c2a:	9d 81       	ldd	r25, Y+5	; 0x05
     c2c:	82 17       	cp	r24, r18
     c2e:	93 07       	cpc	r25, r19
     c30:	e8 f4       	brcc	.+58     	; 0xc6c <vTaskDelayUntil+0xa4>
     c32:	2c 81       	ldd	r18, Y+4	; 0x04
     c34:	3d 81       	ldd	r19, Y+5	; 0x05
     c36:	8a 81       	ldd	r24, Y+2	; 0x02
     c38:	9b 81       	ldd	r25, Y+3	; 0x03
     c3a:	82 17       	cp	r24, r18
     c3c:	93 07       	cpc	r25, r19
     c3e:	b0 f4       	brcc	.+44     	; 0xc6c <vTaskDelayUntil+0xa4>
				{
					xShouldDelay = pdTRUE;
     c40:	81 e0       	ldi	r24, 0x01	; 1
     c42:	89 83       	std	Y+1, r24	; 0x01
     c44:	13 c0       	rjmp	.+38     	; 0xc6c <vTaskDelayUntil+0xa4>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     c46:	8f 81       	ldd	r24, Y+7	; 0x07
     c48:	98 85       	ldd	r25, Y+8	; 0x08
     c4a:	fc 01       	movw	r30, r24
     c4c:	20 81       	ld	r18, Z
     c4e:	31 81       	ldd	r19, Z+1	; 0x01
     c50:	8c 81       	ldd	r24, Y+4	; 0x04
     c52:	9d 81       	ldd	r25, Y+5	; 0x05
     c54:	82 17       	cp	r24, r18
     c56:	93 07       	cpc	r25, r19
     c58:	38 f0       	brcs	.+14     	; 0xc68 <vTaskDelayUntil+0xa0>
     c5a:	2c 81       	ldd	r18, Y+4	; 0x04
     c5c:	3d 81       	ldd	r19, Y+5	; 0x05
     c5e:	8a 81       	ldd	r24, Y+2	; 0x02
     c60:	9b 81       	ldd	r25, Y+3	; 0x03
     c62:	82 17       	cp	r24, r18
     c64:	93 07       	cpc	r25, r19
     c66:	10 f4       	brcc	.+4      	; 0xc6c <vTaskDelayUntil+0xa4>
				{
					xShouldDelay = pdTRUE;
     c68:	81 e0       	ldi	r24, 0x01	; 1
     c6a:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     c6c:	8f 81       	ldd	r24, Y+7	; 0x07
     c6e:	98 85       	ldd	r25, Y+8	; 0x08
     c70:	2c 81       	ldd	r18, Y+4	; 0x04
     c72:	3d 81       	ldd	r19, Y+5	; 0x05
     c74:	fc 01       	movw	r30, r24
     c76:	31 83       	std	Z+1, r19	; 0x01
     c78:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     c7a:	89 81       	ldd	r24, Y+1	; 0x01
     c7c:	88 23       	and	r24, r24
     c7e:	49 f0       	breq	.+18     	; 0xc92 <vTaskDelayUntil+0xca>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     c80:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
     c84:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     c88:	02 96       	adiw	r24, 0x02	; 2
     c8a:	67 de       	rcall	.-818    	; 0x95a <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     c8c:	8c 81       	ldd	r24, Y+4	; 0x04
     c8e:	9d 81       	ldd	r25, Y+5	; 0x05
     c90:	56 d3       	rcall	.+1708   	; 0x133e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     c92:	51 d0       	rcall	.+162    	; 0xd36 <xTaskResumeAll>
     c94:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     c96:	8e 81       	ldd	r24, Y+6	; 0x06
     c98:	88 23       	and	r24, r24
     c9a:	09 f4       	brne	.+2      	; 0xc9e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
     c9c:	40 dc       	rcall	.-1920   	; 0x51e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c9e:	00 00       	nop
     ca0:	2a 96       	adiw	r28, 0x0a	; 10
     ca2:	0f b6       	in	r0, 0x3f	; 63
     ca4:	f8 94       	cli
     ca6:	de bf       	out	0x3e, r29	; 62
     ca8:	0f be       	out	0x3f, r0	; 63
     caa:	cd bf       	out	0x3d, r28	; 61
     cac:	df 91       	pop	r29
     cae:	cf 91       	pop	r28
     cb0:	08 95       	ret

00000cb2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     cb2:	af 92       	push	r10
     cb4:	bf 92       	push	r11
     cb6:	cf 92       	push	r12
     cb8:	df 92       	push	r13
     cba:	ef 92       	push	r14
     cbc:	ff 92       	push	r15
     cbe:	0f 93       	push	r16
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	1f 92       	push	r1
     cc6:	cd b7       	in	r28, 0x3d	; 61
     cc8:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     cca:	a1 2c       	mov	r10, r1
     ccc:	b1 2c       	mov	r11, r1
     cce:	c1 2c       	mov	r12, r1
     cd0:	d1 2c       	mov	r13, r1
     cd2:	e1 2c       	mov	r14, r1
     cd4:	f1 2c       	mov	r15, r1
     cd6:	00 e0       	ldi	r16, 0x00	; 0
     cd8:	20 e0       	ldi	r18, 0x00	; 0
     cda:	30 e0       	ldi	r19, 0x00	; 0
     cdc:	45 e5       	ldi	r20, 0x55	; 85
     cde:	50 e0       	ldi	r21, 0x00	; 0
     ce0:	62 e0       	ldi	r22, 0x02	; 2
     ce2:	71 e0       	ldi	r23, 0x01	; 1
     ce4:	86 e9       	ldi	r24, 0x96	; 150
     ce6:	98 e0       	ldi	r25, 0x08	; 8
     ce8:	8f de       	rcall	.-738    	; 0xa08 <xTaskGenericCreate>
     cea:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     cec:	89 81       	ldd	r24, Y+1	; 0x01
     cee:	81 30       	cpi	r24, 0x01	; 1
     cf0:	49 f4       	brne	.+18     	; 0xd04 <vTaskStartScheduler+0x52>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     cf2:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	80 93 3f 07 	sts	0x073F, r24	; 0x80073f <xSchedulerRunning>
		xTickCount = ( TickType_t ) 0U;
     cfa:	10 92 3d 07 	sts	0x073D, r1	; 0x80073d <xTickCount+0x1>
     cfe:	10 92 3c 07 	sts	0x073C, r1	; 0x80073c <xTickCount>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     d02:	d9 db       	rcall	.-2126   	; 0x4b6 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     d04:	00 00       	nop
     d06:	0f 90       	pop	r0
     d08:	df 91       	pop	r29
     d0a:	cf 91       	pop	r28
     d0c:	0f 91       	pop	r16
     d0e:	ff 90       	pop	r15
     d10:	ef 90       	pop	r14
     d12:	df 90       	pop	r13
     d14:	cf 90       	pop	r12
     d16:	bf 90       	pop	r11
     d18:	af 90       	pop	r10
     d1a:	08 95       	ret

00000d1c <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     d1c:	cf 93       	push	r28
     d1e:	df 93       	push	r29
     d20:	cd b7       	in	r28, 0x3d	; 61
     d22:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     d24:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <uxSchedulerSuspended>
     d28:	8f 5f       	subi	r24, 0xFF	; 255
     d2a:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <uxSchedulerSuspended>
}
     d2e:	00 00       	nop
     d30:	df 91       	pop	r29
     d32:	cf 91       	pop	r28
     d34:	08 95       	ret

00000d36 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	00 d0       	rcall	.+0      	; 0xd3c <xTaskResumeAll+0x6>
     d3c:	1f 92       	push	r1
     d3e:	cd b7       	in	r28, 0x3d	; 61
     d40:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     d42:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     d44:	0f b6       	in	r0, 0x3f	; 63
     d46:	f8 94       	cli
     d48:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     d4a:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <uxSchedulerSuspended>
     d4e:	81 50       	subi	r24, 0x01	; 1
     d50:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     d54:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <uxSchedulerSuspended>
     d58:	88 23       	and	r24, r24
     d5a:	09 f0       	breq	.+2      	; 0xd5e <xTaskResumeAll+0x28>
     d5c:	6c c0       	rjmp	.+216    	; 0xe36 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     d5e:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxCurrentNumberOfTasks>
     d62:	88 23       	and	r24, r24
     d64:	09 f4       	brne	.+2      	; 0xd68 <xTaskResumeAll+0x32>
     d66:	67 c0       	rjmp	.+206    	; 0xe36 <xTaskResumeAll+0x100>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     d68:	46 c0       	rjmp	.+140    	; 0xdf6 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     d6a:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <xPendingReadyList+0x5>
     d6e:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <xPendingReadyList+0x6>
     d72:	fc 01       	movw	r30, r24
     d74:	86 81       	ldd	r24, Z+6	; 0x06
     d76:	97 81       	ldd	r25, Z+7	; 0x07
     d78:	9b 83       	std	Y+3, r25	; 0x03
     d7a:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     d7c:	8a 81       	ldd	r24, Y+2	; 0x02
     d7e:	9b 81       	ldd	r25, Y+3	; 0x03
     d80:	0c 96       	adiw	r24, 0x0c	; 12
     d82:	eb dd       	rcall	.-1066   	; 0x95a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     d84:	8a 81       	ldd	r24, Y+2	; 0x02
     d86:	9b 81       	ldd	r25, Y+3	; 0x03
     d88:	02 96       	adiw	r24, 0x02	; 2
     d8a:	e7 dd       	rcall	.-1074   	; 0x95a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	96 89       	ldd	r25, Z+22	; 0x16
     d94:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
     d98:	89 17       	cp	r24, r25
     d9a:	30 f4       	brcc	.+12     	; 0xda8 <xTaskResumeAll+0x72>
     d9c:	8a 81       	ldd	r24, Y+2	; 0x02
     d9e:	9b 81       	ldd	r25, Y+3	; 0x03
     da0:	fc 01       	movw	r30, r24
     da2:	86 89       	ldd	r24, Z+22	; 0x16
     da4:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <uxTopReadyPriority>
     da8:	8a 81       	ldd	r24, Y+2	; 0x02
     daa:	9b 81       	ldd	r25, Y+3	; 0x03
     dac:	ac 01       	movw	r20, r24
     dae:	4e 5f       	subi	r20, 0xFE	; 254
     db0:	5f 4f       	sbci	r21, 0xFF	; 255
     db2:	8a 81       	ldd	r24, Y+2	; 0x02
     db4:	9b 81       	ldd	r25, Y+3	; 0x03
     db6:	fc 01       	movw	r30, r24
     db8:	86 89       	ldd	r24, Z+22	; 0x16
     dba:	28 2f       	mov	r18, r24
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	c9 01       	movw	r24, r18
     dc0:	88 0f       	add	r24, r24
     dc2:	99 1f       	adc	r25, r25
     dc4:	88 0f       	add	r24, r24
     dc6:	99 1f       	adc	r25, r25
     dc8:	88 0f       	add	r24, r24
     dca:	99 1f       	adc	r25, r25
     dcc:	82 0f       	add	r24, r18
     dce:	93 1f       	adc	r25, r19
     dd0:	82 51       	subi	r24, 0x12	; 18
     dd2:	99 4f       	sbci	r25, 0xF9	; 249
     dd4:	ba 01       	movw	r22, r20
     dd6:	fa dc       	rcall	.-1548   	; 0x7cc <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     dd8:	8a 81       	ldd	r24, Y+2	; 0x02
     dda:	9b 81       	ldd	r25, Y+3	; 0x03
     ddc:	fc 01       	movw	r30, r24
     dde:	26 89       	ldd	r18, Z+22	; 0x16
     de0:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
     de4:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     de8:	fc 01       	movw	r30, r24
     dea:	86 89       	ldd	r24, Z+22	; 0x16
     dec:	28 17       	cp	r18, r24
     dee:	18 f0       	brcs	.+6      	; 0xdf6 <xTaskResumeAll+0xc0>
					{
						xYieldPending = pdTRUE;
     df0:	81 e0       	ldi	r24, 0x01	; 1
     df2:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     df6:	80 91 28 07 	lds	r24, 0x0728	; 0x800728 <xPendingReadyList>
     dfa:	88 23       	and	r24, r24
     dfc:	09 f0       	breq	.+2      	; 0xe00 <xTaskResumeAll+0xca>
     dfe:	b5 cf       	rjmp	.-150    	; 0xd6a <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     e00:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxPendedTicks>
     e04:	88 23       	and	r24, r24
     e06:	81 f0       	breq	.+32     	; 0xe28 <xTaskResumeAll+0xf2>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e08:	0b c0       	rjmp	.+22     	; 0xe20 <xTaskResumeAll+0xea>
					{
						if( xTaskIncrementTick() != pdFALSE )
     e0a:	35 d0       	rcall	.+106    	; 0xe76 <xTaskIncrementTick>
     e0c:	88 23       	and	r24, r24
     e0e:	19 f0       	breq	.+6      	; 0xe16 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
     e10:	81 e0       	ldi	r24, 0x01	; 1
     e12:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <xYieldPending>
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     e16:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxPendedTicks>
     e1a:	81 50       	subi	r24, 0x01	; 1
     e1c:	80 93 40 07 	sts	0x0740, r24	; 0x800740 <uxPendedTicks>
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e20:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxPendedTicks>
     e24:	88 23       	and	r24, r24
     e26:	89 f7       	brne	.-30     	; 0xe0a <xTaskResumeAll+0xd4>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     e28:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <xYieldPending>
     e2c:	81 30       	cpi	r24, 0x01	; 1
     e2e:	19 f4       	brne	.+6      	; 0xe36 <xTaskResumeAll+0x100>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     e34:	74 db       	rcall	.-2328   	; 0x51e <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     e36:	0f 90       	pop	r0
     e38:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     e3a:	89 81       	ldd	r24, Y+1	; 0x01
}
     e3c:	0f 90       	pop	r0
     e3e:	0f 90       	pop	r0
     e40:	0f 90       	pop	r0
     e42:	df 91       	pop	r29
     e44:	cf 91       	pop	r28
     e46:	08 95       	ret

00000e48 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
     e48:	cf 93       	push	r28
     e4a:	df 93       	push	r29
     e4c:	00 d0       	rcall	.+0      	; 0xe4e <xTaskGetTickCount+0x6>
     e4e:	cd b7       	in	r28, 0x3d	; 61
     e50:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	f8 94       	cli
     e56:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     e58:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <xTickCount>
     e5c:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <xTickCount+0x1>
     e60:	9a 83       	std	Y+2, r25	; 0x02
     e62:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
     e64:	0f 90       	pop	r0
     e66:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     e68:	89 81       	ldd	r24, Y+1	; 0x01
     e6a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e6c:	0f 90       	pop	r0
     e6e:	0f 90       	pop	r0
     e70:	df 91       	pop	r29
     e72:	cf 91       	pop	r28
     e74:	08 95       	ret

00000e76 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     e76:	cf 93       	push	r28
     e78:	df 93       	push	r29
     e7a:	cd b7       	in	r28, 0x3d	; 61
     e7c:	de b7       	in	r29, 0x3e	; 62
     e7e:	29 97       	sbiw	r28, 0x09	; 9
     e80:	0f b6       	in	r0, 0x3f	; 63
     e82:	f8 94       	cli
     e84:	de bf       	out	0x3e, r29	; 62
     e86:	0f be       	out	0x3f, r0	; 63
     e88:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     e8a:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e8c:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <uxSchedulerSuspended>
     e90:	88 23       	and	r24, r24
     e92:	09 f0       	breq	.+2      	; 0xe96 <xTaskIncrementTick+0x20>
     e94:	c6 c0       	rjmp	.+396    	; 0x1022 <xTaskIncrementTick+0x1ac>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     e96:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <xTickCount>
     e9a:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <xTickCount+0x1>
     e9e:	01 96       	adiw	r24, 0x01	; 1
     ea0:	90 93 3d 07 	sts	0x073D, r25	; 0x80073d <xTickCount+0x1>
     ea4:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <xTickCount>

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     ea8:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <xTickCount>
     eac:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <xTickCount+0x1>
     eb0:	9b 83       	std	Y+3, r25	; 0x03
     eb2:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
     eb4:	8a 81       	ldd	r24, Y+2	; 0x02
     eb6:	9b 81       	ldd	r25, Y+3	; 0x03
     eb8:	89 2b       	or	r24, r25
     eba:	d1 f4       	brne	.+52     	; 0xef0 <xTaskIncrementTick+0x7a>
			{
				taskSWITCH_DELAYED_LISTS();
     ebc:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <pxDelayedTaskList>
     ec0:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <pxDelayedTaskList+0x1>
     ec4:	9d 83       	std	Y+5, r25	; 0x05
     ec6:	8c 83       	std	Y+4, r24	; 0x04
     ec8:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <pxOverflowDelayedTaskList>
     ecc:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <pxOverflowDelayedTaskList+0x1>
     ed0:	90 93 25 07 	sts	0x0725, r25	; 0x800725 <pxDelayedTaskList+0x1>
     ed4:	80 93 24 07 	sts	0x0724, r24	; 0x800724 <pxDelayedTaskList>
     ed8:	8c 81       	ldd	r24, Y+4	; 0x04
     eda:	9d 81       	ldd	r25, Y+5	; 0x05
     edc:	90 93 27 07 	sts	0x0727, r25	; 0x800727 <pxOverflowDelayedTaskList+0x1>
     ee0:	80 93 26 07 	sts	0x0726, r24	; 0x800726 <pxOverflowDelayedTaskList>
     ee4:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <xNumOfOverflows>
     ee8:	8f 5f       	subi	r24, 0xFF	; 255
     eea:	80 93 42 07 	sts	0x0742, r24	; 0x800742 <xNumOfOverflows>
     eee:	cb d2       	rcall	.+1430   	; 0x1486 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     ef0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     ef4:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     ef8:	2a 81       	ldd	r18, Y+2	; 0x02
     efa:	3b 81       	ldd	r19, Y+3	; 0x03
     efc:	28 17       	cp	r18, r24
     efe:	39 07       	cpc	r19, r25
     f00:	08 f4       	brcc	.+2      	; 0xf04 <xTaskIncrementTick+0x8e>
     f02:	75 c0       	rjmp	.+234    	; 0xfee <xTaskIncrementTick+0x178>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     f04:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <pxDelayedTaskList>
     f08:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <pxDelayedTaskList+0x1>
     f0c:	fc 01       	movw	r30, r24
     f0e:	80 81       	ld	r24, Z
     f10:	88 23       	and	r24, r24
     f12:	39 f4       	brne	.+14     	; 0xf22 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     f14:	8f ef       	ldi	r24, 0xFF	; 255
     f16:	9f ef       	ldi	r25, 0xFF	; 255
     f18:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     f1c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
						break;
     f20:	66 c0       	rjmp	.+204    	; 0xfee <xTaskIncrementTick+0x178>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     f22:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <pxDelayedTaskList>
     f26:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <pxDelayedTaskList+0x1>
     f2a:	fc 01       	movw	r30, r24
     f2c:	85 81       	ldd	r24, Z+5	; 0x05
     f2e:	96 81       	ldd	r25, Z+6	; 0x06
     f30:	fc 01       	movw	r30, r24
     f32:	86 81       	ldd	r24, Z+6	; 0x06
     f34:	97 81       	ldd	r25, Z+7	; 0x07
     f36:	9f 83       	std	Y+7, r25	; 0x07
     f38:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     f3a:	8e 81       	ldd	r24, Y+6	; 0x06
     f3c:	9f 81       	ldd	r25, Y+7	; 0x07
     f3e:	fc 01       	movw	r30, r24
     f40:	82 81       	ldd	r24, Z+2	; 0x02
     f42:	93 81       	ldd	r25, Z+3	; 0x03
     f44:	99 87       	std	Y+9, r25	; 0x09
     f46:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
     f48:	2a 81       	ldd	r18, Y+2	; 0x02
     f4a:	3b 81       	ldd	r19, Y+3	; 0x03
     f4c:	88 85       	ldd	r24, Y+8	; 0x08
     f4e:	99 85       	ldd	r25, Y+9	; 0x09
     f50:	28 17       	cp	r18, r24
     f52:	39 07       	cpc	r19, r25
     f54:	38 f4       	brcc	.+14     	; 0xf64 <xTaskIncrementTick+0xee>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     f56:	88 85       	ldd	r24, Y+8	; 0x08
     f58:	99 85       	ldd	r25, Y+9	; 0x09
     f5a:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     f5e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
							break;
     f62:	45 c0       	rjmp	.+138    	; 0xfee <xTaskIncrementTick+0x178>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     f64:	8e 81       	ldd	r24, Y+6	; 0x06
     f66:	9f 81       	ldd	r25, Y+7	; 0x07
     f68:	02 96       	adiw	r24, 0x02	; 2
     f6a:	f7 dc       	rcall	.-1554   	; 0x95a <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     f6c:	8e 81       	ldd	r24, Y+6	; 0x06
     f6e:	9f 81       	ldd	r25, Y+7	; 0x07
     f70:	fc 01       	movw	r30, r24
     f72:	84 89       	ldd	r24, Z+20	; 0x14
     f74:	95 89       	ldd	r25, Z+21	; 0x15
     f76:	89 2b       	or	r24, r25
     f78:	21 f0       	breq	.+8      	; 0xf82 <xTaskIncrementTick+0x10c>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     f7a:	8e 81       	ldd	r24, Y+6	; 0x06
     f7c:	9f 81       	ldd	r25, Y+7	; 0x07
     f7e:	0c 96       	adiw	r24, 0x0c	; 12
     f80:	ec dc       	rcall	.-1576   	; 0x95a <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     f82:	8e 81       	ldd	r24, Y+6	; 0x06
     f84:	9f 81       	ldd	r25, Y+7	; 0x07
     f86:	fc 01       	movw	r30, r24
     f88:	96 89       	ldd	r25, Z+22	; 0x16
     f8a:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
     f8e:	89 17       	cp	r24, r25
     f90:	30 f4       	brcc	.+12     	; 0xf9e <xTaskIncrementTick+0x128>
     f92:	8e 81       	ldd	r24, Y+6	; 0x06
     f94:	9f 81       	ldd	r25, Y+7	; 0x07
     f96:	fc 01       	movw	r30, r24
     f98:	86 89       	ldd	r24, Z+22	; 0x16
     f9a:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <uxTopReadyPriority>
     f9e:	8e 81       	ldd	r24, Y+6	; 0x06
     fa0:	9f 81       	ldd	r25, Y+7	; 0x07
     fa2:	ac 01       	movw	r20, r24
     fa4:	4e 5f       	subi	r20, 0xFE	; 254
     fa6:	5f 4f       	sbci	r21, 0xFF	; 255
     fa8:	8e 81       	ldd	r24, Y+6	; 0x06
     faa:	9f 81       	ldd	r25, Y+7	; 0x07
     fac:	fc 01       	movw	r30, r24
     fae:	86 89       	ldd	r24, Z+22	; 0x16
     fb0:	28 2f       	mov	r18, r24
     fb2:	30 e0       	ldi	r19, 0x00	; 0
     fb4:	c9 01       	movw	r24, r18
     fb6:	88 0f       	add	r24, r24
     fb8:	99 1f       	adc	r25, r25
     fba:	88 0f       	add	r24, r24
     fbc:	99 1f       	adc	r25, r25
     fbe:	88 0f       	add	r24, r24
     fc0:	99 1f       	adc	r25, r25
     fc2:	82 0f       	add	r24, r18
     fc4:	93 1f       	adc	r25, r19
     fc6:	82 51       	subi	r24, 0x12	; 18
     fc8:	99 4f       	sbci	r25, 0xF9	; 249
     fca:	ba 01       	movw	r22, r20
     fcc:	ff db       	rcall	.-2050   	; 0x7cc <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     fce:	8e 81       	ldd	r24, Y+6	; 0x06
     fd0:	9f 81       	ldd	r25, Y+7	; 0x07
     fd2:	fc 01       	movw	r30, r24
     fd4:	26 89       	ldd	r18, Z+22	; 0x16
     fd6:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
     fda:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     fde:	fc 01       	movw	r30, r24
     fe0:	86 89       	ldd	r24, Z+22	; 0x16
     fe2:	28 17       	cp	r18, r24
     fe4:	08 f4       	brcc	.+2      	; 0xfe8 <xTaskIncrementTick+0x172>
     fe6:	8e cf       	rjmp	.-228    	; 0xf04 <xTaskIncrementTick+0x8e>
							{
								xSwitchRequired = pdTRUE;
     fe8:	81 e0       	ldi	r24, 0x01	; 1
     fea:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
     fec:	8b cf       	rjmp	.-234    	; 0xf04 <xTaskIncrementTick+0x8e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     fee:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
     ff2:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
     ff6:	fc 01       	movw	r30, r24
     ff8:	86 89       	ldd	r24, Z+22	; 0x16
     ffa:	28 2f       	mov	r18, r24
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	c9 01       	movw	r24, r18
    1000:	88 0f       	add	r24, r24
    1002:	99 1f       	adc	r25, r25
    1004:	88 0f       	add	r24, r24
    1006:	99 1f       	adc	r25, r25
    1008:	88 0f       	add	r24, r24
    100a:	99 1f       	adc	r25, r25
    100c:	82 0f       	add	r24, r18
    100e:	93 1f       	adc	r25, r19
    1010:	82 51       	subi	r24, 0x12	; 18
    1012:	99 4f       	sbci	r25, 0xF9	; 249
    1014:	fc 01       	movw	r30, r24
    1016:	80 81       	ld	r24, Z
    1018:	82 30       	cpi	r24, 0x02	; 2
    101a:	40 f0       	brcs	.+16     	; 0x102c <xTaskIncrementTick+0x1b6>
			{
				xSwitchRequired = pdTRUE;
    101c:	81 e0       	ldi	r24, 0x01	; 1
    101e:	89 83       	std	Y+1, r24	; 0x01
    1020:	05 c0       	rjmp	.+10     	; 0x102c <xTaskIncrementTick+0x1b6>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1022:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxPendedTicks>
    1026:	8f 5f       	subi	r24, 0xFF	; 255
    1028:	80 93 40 07 	sts	0x0740, r24	; 0x800740 <uxPendedTicks>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    102c:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <xYieldPending>
    1030:	88 23       	and	r24, r24
    1032:	11 f0       	breq	.+4      	; 0x1038 <xTaskIncrementTick+0x1c2>
		{
			xSwitchRequired = pdTRUE;
    1034:	81 e0       	ldi	r24, 0x01	; 1
    1036:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    1038:	89 81       	ldd	r24, Y+1	; 0x01
}
    103a:	29 96       	adiw	r28, 0x09	; 9
    103c:	0f b6       	in	r0, 0x3f	; 63
    103e:	f8 94       	cli
    1040:	de bf       	out	0x3e, r29	; 62
    1042:	0f be       	out	0x3f, r0	; 63
    1044:	cd bf       	out	0x3d, r28	; 61
    1046:	df 91       	pop	r29
    1048:	cf 91       	pop	r28
    104a:	08 95       	ret

0000104c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	00 d0       	rcall	.+0      	; 0x1052 <vTaskSwitchContext+0x6>
    1052:	cd b7       	in	r28, 0x3d	; 61
    1054:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1056:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <uxSchedulerSuspended>
    105a:	88 23       	and	r24, r24
    105c:	21 f0       	breq	.+8      	; 0x1066 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    105e:	81 e0       	ldi	r24, 0x01	; 1
    1060:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <xYieldPending>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    1064:	5d c0       	rjmp	.+186    	; 0x1120 <vTaskSwitchContext+0xd4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    1066:	10 92 41 07 	sts	0x0741, r1	; 0x800741 <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    106a:	05 c0       	rjmp	.+10     	; 0x1076 <vTaskSwitchContext+0x2a>
    106c:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    1070:	81 50       	subi	r24, 0x01	; 1
    1072:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <uxTopReadyPriority>
    1076:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    107a:	28 2f       	mov	r18, r24
    107c:	30 e0       	ldi	r19, 0x00	; 0
    107e:	c9 01       	movw	r24, r18
    1080:	88 0f       	add	r24, r24
    1082:	99 1f       	adc	r25, r25
    1084:	88 0f       	add	r24, r24
    1086:	99 1f       	adc	r25, r25
    1088:	88 0f       	add	r24, r24
    108a:	99 1f       	adc	r25, r25
    108c:	82 0f       	add	r24, r18
    108e:	93 1f       	adc	r25, r19
    1090:	82 51       	subi	r24, 0x12	; 18
    1092:	99 4f       	sbci	r25, 0xF9	; 249
    1094:	fc 01       	movw	r30, r24
    1096:	80 81       	ld	r24, Z
    1098:	88 23       	and	r24, r24
    109a:	41 f3       	breq	.-48     	; 0x106c <vTaskSwitchContext+0x20>
    109c:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    10a0:	28 2f       	mov	r18, r24
    10a2:	30 e0       	ldi	r19, 0x00	; 0
    10a4:	c9 01       	movw	r24, r18
    10a6:	88 0f       	add	r24, r24
    10a8:	99 1f       	adc	r25, r25
    10aa:	88 0f       	add	r24, r24
    10ac:	99 1f       	adc	r25, r25
    10ae:	88 0f       	add	r24, r24
    10b0:	99 1f       	adc	r25, r25
    10b2:	82 0f       	add	r24, r18
    10b4:	93 1f       	adc	r25, r19
    10b6:	82 51       	subi	r24, 0x12	; 18
    10b8:	99 4f       	sbci	r25, 0xF9	; 249
    10ba:	9a 83       	std	Y+2, r25	; 0x02
    10bc:	89 83       	std	Y+1, r24	; 0x01
    10be:	89 81       	ldd	r24, Y+1	; 0x01
    10c0:	9a 81       	ldd	r25, Y+2	; 0x02
    10c2:	fc 01       	movw	r30, r24
    10c4:	81 81       	ldd	r24, Z+1	; 0x01
    10c6:	92 81       	ldd	r25, Z+2	; 0x02
    10c8:	fc 01       	movw	r30, r24
    10ca:	22 81       	ldd	r18, Z+2	; 0x02
    10cc:	33 81       	ldd	r19, Z+3	; 0x03
    10ce:	89 81       	ldd	r24, Y+1	; 0x01
    10d0:	9a 81       	ldd	r25, Y+2	; 0x02
    10d2:	fc 01       	movw	r30, r24
    10d4:	32 83       	std	Z+2, r19	; 0x02
    10d6:	21 83       	std	Z+1, r18	; 0x01
    10d8:	89 81       	ldd	r24, Y+1	; 0x01
    10da:	9a 81       	ldd	r25, Y+2	; 0x02
    10dc:	fc 01       	movw	r30, r24
    10de:	21 81       	ldd	r18, Z+1	; 0x01
    10e0:	32 81       	ldd	r19, Z+2	; 0x02
    10e2:	89 81       	ldd	r24, Y+1	; 0x01
    10e4:	9a 81       	ldd	r25, Y+2	; 0x02
    10e6:	03 96       	adiw	r24, 0x03	; 3
    10e8:	28 17       	cp	r18, r24
    10ea:	39 07       	cpc	r19, r25
    10ec:	69 f4       	brne	.+26     	; 0x1108 <vTaskSwitchContext+0xbc>
    10ee:	89 81       	ldd	r24, Y+1	; 0x01
    10f0:	9a 81       	ldd	r25, Y+2	; 0x02
    10f2:	fc 01       	movw	r30, r24
    10f4:	81 81       	ldd	r24, Z+1	; 0x01
    10f6:	92 81       	ldd	r25, Z+2	; 0x02
    10f8:	fc 01       	movw	r30, r24
    10fa:	22 81       	ldd	r18, Z+2	; 0x02
    10fc:	33 81       	ldd	r19, Z+3	; 0x03
    10fe:	89 81       	ldd	r24, Y+1	; 0x01
    1100:	9a 81       	ldd	r25, Y+2	; 0x02
    1102:	fc 01       	movw	r30, r24
    1104:	32 83       	std	Z+2, r19	; 0x02
    1106:	21 83       	std	Z+1, r18	; 0x01
    1108:	89 81       	ldd	r24, Y+1	; 0x01
    110a:	9a 81       	ldd	r25, Y+2	; 0x02
    110c:	fc 01       	movw	r30, r24
    110e:	81 81       	ldd	r24, Z+1	; 0x01
    1110:	92 81       	ldd	r25, Z+2	; 0x02
    1112:	fc 01       	movw	r30, r24
    1114:	86 81       	ldd	r24, Z+6	; 0x06
    1116:	97 81       	ldd	r25, Z+7	; 0x07
    1118:	90 93 ed 06 	sts	0x06ED, r25	; 0x8006ed <pxCurrentTCB+0x1>
    111c:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <pxCurrentTCB>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    1120:	00 00       	nop
    1122:	0f 90       	pop	r0
    1124:	0f 90       	pop	r0
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	08 95       	ret

0000112c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	00 d0       	rcall	.+0      	; 0x1132 <prvIdleTask+0x6>
    1132:	cd b7       	in	r28, 0x3d	; 61
    1134:	de b7       	in	r29, 0x3e	; 62
    1136:	9a 83       	std	Y+2, r25	; 0x02
    1138:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    113a:	c4 d0       	rcall	.+392    	; 0x12c4 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    113c:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <pxReadyTasksLists>
    1140:	82 30       	cpi	r24, 0x02	; 2
    1142:	08 f0       	brcs	.+2      	; 0x1146 <prvIdleTask+0x1a>
			{
				taskYIELD();
    1144:	ec d9       	rcall	.-3112   	; 0x51e <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    1146:	32 d2       	rcall	.+1124   	; 0x15ac <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    1148:	f8 cf       	rjmp	.-16     	; 0x113a <prvIdleTask+0xe>

0000114a <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    114a:	0f 93       	push	r16
    114c:	1f 93       	push	r17
    114e:	cf 93       	push	r28
    1150:	df 93       	push	r29
    1152:	cd b7       	in	r28, 0x3d	; 61
    1154:	de b7       	in	r29, 0x3e	; 62
    1156:	2a 97       	sbiw	r28, 0x0a	; 10
    1158:	0f b6       	in	r0, 0x3f	; 63
    115a:	f8 94       	cli
    115c:	de bf       	out	0x3e, r29	; 62
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	cd bf       	out	0x3d, r28	; 61
    1162:	9b 83       	std	Y+3, r25	; 0x03
    1164:	8a 83       	std	Y+2, r24	; 0x02
    1166:	7d 83       	std	Y+5, r23	; 0x05
    1168:	6c 83       	std	Y+4, r22	; 0x04
    116a:	4e 83       	std	Y+6, r20	; 0x06
    116c:	38 87       	std	Y+8, r19	; 0x08
    116e:	2f 83       	std	Y+7, r18	; 0x07
    1170:	1a 87       	std	Y+10, r17	; 0x0a
    1172:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1174:	19 82       	std	Y+1, r1	; 0x01
    1176:	21 c0       	rjmp	.+66     	; 0x11ba <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1178:	89 81       	ldd	r24, Y+1	; 0x01
    117a:	88 2f       	mov	r24, r24
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	29 81       	ldd	r18, Y+1	; 0x01
    1180:	22 2f       	mov	r18, r18
    1182:	30 e0       	ldi	r19, 0x00	; 0
    1184:	4c 81       	ldd	r20, Y+4	; 0x04
    1186:	5d 81       	ldd	r21, Y+5	; 0x05
    1188:	24 0f       	add	r18, r20
    118a:	35 1f       	adc	r19, r21
    118c:	f9 01       	movw	r30, r18
    118e:	40 81       	ld	r20, Z
    1190:	2a 81       	ldd	r18, Y+2	; 0x02
    1192:	3b 81       	ldd	r19, Y+3	; 0x03
    1194:	82 0f       	add	r24, r18
    1196:	93 1f       	adc	r25, r19
    1198:	49 96       	adiw	r24, 0x19	; 25
    119a:	fc 01       	movw	r30, r24
    119c:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    119e:	89 81       	ldd	r24, Y+1	; 0x01
    11a0:	88 2f       	mov	r24, r24
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	2c 81       	ldd	r18, Y+4	; 0x04
    11a6:	3d 81       	ldd	r19, Y+5	; 0x05
    11a8:	82 0f       	add	r24, r18
    11aa:	93 1f       	adc	r25, r19
    11ac:	fc 01       	movw	r30, r24
    11ae:	80 81       	ld	r24, Z
    11b0:	88 23       	and	r24, r24
    11b2:	39 f0       	breq	.+14     	; 0x11c2 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    11b4:	89 81       	ldd	r24, Y+1	; 0x01
    11b6:	8f 5f       	subi	r24, 0xFF	; 255
    11b8:	89 83       	std	Y+1, r24	; 0x01
    11ba:	89 81       	ldd	r24, Y+1	; 0x01
    11bc:	88 30       	cpi	r24, 0x08	; 8
    11be:	e0 f2       	brcs	.-72     	; 0x1178 <prvInitialiseTCBVariables+0x2e>
    11c0:	01 c0       	rjmp	.+2      	; 0x11c4 <prvInitialiseTCBVariables+0x7a>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
    11c2:	00 00       	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    11c4:	8a 81       	ldd	r24, Y+2	; 0x02
    11c6:	9b 81       	ldd	r25, Y+3	; 0x03
    11c8:	fc 01       	movw	r30, r24
    11ca:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    11cc:	8e 81       	ldd	r24, Y+6	; 0x06
    11ce:	84 30       	cpi	r24, 0x04	; 4
    11d0:	10 f0       	brcs	.+4      	; 0x11d6 <prvInitialiseTCBVariables+0x8c>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    11d2:	83 e0       	ldi	r24, 0x03	; 3
    11d4:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    11d6:	8a 81       	ldd	r24, Y+2	; 0x02
    11d8:	9b 81       	ldd	r25, Y+3	; 0x03
    11da:	2e 81       	ldd	r18, Y+6	; 0x06
    11dc:	fc 01       	movw	r30, r24
    11de:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    11e0:	8a 81       	ldd	r24, Y+2	; 0x02
    11e2:	9b 81       	ldd	r25, Y+3	; 0x03
    11e4:	02 96       	adiw	r24, 0x02	; 2
    11e6:	e0 da       	rcall	.-2624   	; 0x7a8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    11e8:	8a 81       	ldd	r24, Y+2	; 0x02
    11ea:	9b 81       	ldd	r25, Y+3	; 0x03
    11ec:	0c 96       	adiw	r24, 0x0c	; 12
    11ee:	dc da       	rcall	.-2632   	; 0x7a8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    11f0:	8a 81       	ldd	r24, Y+2	; 0x02
    11f2:	9b 81       	ldd	r25, Y+3	; 0x03
    11f4:	2a 81       	ldd	r18, Y+2	; 0x02
    11f6:	3b 81       	ldd	r19, Y+3	; 0x03
    11f8:	fc 01       	movw	r30, r24
    11fa:	31 87       	std	Z+9, r19	; 0x09
    11fc:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11fe:	8e 81       	ldd	r24, Y+6	; 0x06
    1200:	88 2f       	mov	r24, r24
    1202:	90 e0       	ldi	r25, 0x00	; 0
    1204:	24 e0       	ldi	r18, 0x04	; 4
    1206:	30 e0       	ldi	r19, 0x00	; 0
    1208:	28 1b       	sub	r18, r24
    120a:	39 0b       	sbc	r19, r25
    120c:	8a 81       	ldd	r24, Y+2	; 0x02
    120e:	9b 81       	ldd	r25, Y+3	; 0x03
    1210:	fc 01       	movw	r30, r24
    1212:	35 87       	std	Z+13, r19	; 0x0d
    1214:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1216:	8a 81       	ldd	r24, Y+2	; 0x02
    1218:	9b 81       	ldd	r25, Y+3	; 0x03
    121a:	2a 81       	ldd	r18, Y+2	; 0x02
    121c:	3b 81       	ldd	r19, Y+3	; 0x03
    121e:	fc 01       	movw	r30, r24
    1220:	33 8b       	std	Z+19, r19	; 0x13
    1222:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif /* portUSING_MPU_WRAPPERS */

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    1224:	8a 81       	ldd	r24, Y+2	; 0x02
    1226:	9b 81       	ldd	r25, Y+3	; 0x03
    1228:	fc 01       	movw	r30, r24
    122a:	11 a2       	std	Z+33, r1	; 0x21
    122c:	12 a2       	std	Z+34, r1	; 0x22
    122e:	13 a2       	std	Z+35, r1	; 0x23
    1230:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    1232:	8a 81       	ldd	r24, Y+2	; 0x02
    1234:	9b 81       	ldd	r25, Y+3	; 0x03
    1236:	fc 01       	movw	r30, r24
    1238:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    123a:	00 00       	nop
    123c:	2a 96       	adiw	r28, 0x0a	; 10
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	de bf       	out	0x3e, r29	; 62
    1244:	0f be       	out	0x3f, r0	; 63
    1246:	cd bf       	out	0x3d, r28	; 61
    1248:	df 91       	pop	r29
    124a:	cf 91       	pop	r28
    124c:	1f 91       	pop	r17
    124e:	0f 91       	pop	r16
    1250:	08 95       	ret

00001252 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    1252:	cf 93       	push	r28
    1254:	df 93       	push	r29
    1256:	1f 92       	push	r1
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    125c:	19 82       	std	Y+1, r1	; 0x01
    125e:	12 c0       	rjmp	.+36     	; 0x1284 <prvInitialiseTaskLists+0x32>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1260:	89 81       	ldd	r24, Y+1	; 0x01
    1262:	28 2f       	mov	r18, r24
    1264:	30 e0       	ldi	r19, 0x00	; 0
    1266:	c9 01       	movw	r24, r18
    1268:	88 0f       	add	r24, r24
    126a:	99 1f       	adc	r25, r25
    126c:	88 0f       	add	r24, r24
    126e:	99 1f       	adc	r25, r25
    1270:	88 0f       	add	r24, r24
    1272:	99 1f       	adc	r25, r25
    1274:	82 0f       	add	r24, r18
    1276:	93 1f       	adc	r25, r19
    1278:	82 51       	subi	r24, 0x12	; 18
    127a:	99 4f       	sbci	r25, 0xF9	; 249
    127c:	5f da       	rcall	.-2882   	; 0x73c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    127e:	89 81       	ldd	r24, Y+1	; 0x01
    1280:	8f 5f       	subi	r24, 0xFF	; 255
    1282:	89 83       	std	Y+1, r24	; 0x01
    1284:	89 81       	ldd	r24, Y+1	; 0x01
    1286:	84 30       	cpi	r24, 0x04	; 4
    1288:	58 f3       	brcs	.-42     	; 0x1260 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    128a:	82 e1       	ldi	r24, 0x12	; 18
    128c:	97 e0       	ldi	r25, 0x07	; 7
    128e:	56 da       	rcall	.-2900   	; 0x73c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1290:	8b e1       	ldi	r24, 0x1B	; 27
    1292:	97 e0       	ldi	r25, 0x07	; 7
    1294:	53 da       	rcall	.-2906   	; 0x73c <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1296:	88 e2       	ldi	r24, 0x28	; 40
    1298:	97 e0       	ldi	r25, 0x07	; 7
    129a:	50 da       	rcall	.-2912   	; 0x73c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    129c:	81 e3       	ldi	r24, 0x31	; 49
    129e:	97 e0       	ldi	r25, 0x07	; 7
    12a0:	4d da       	rcall	.-2918   	; 0x73c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    12a2:	82 e1       	ldi	r24, 0x12	; 18
    12a4:	97 e0       	ldi	r25, 0x07	; 7
    12a6:	90 93 25 07 	sts	0x0725, r25	; 0x800725 <pxDelayedTaskList+0x1>
    12aa:	80 93 24 07 	sts	0x0724, r24	; 0x800724 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    12ae:	8b e1       	ldi	r24, 0x1B	; 27
    12b0:	97 e0       	ldi	r25, 0x07	; 7
    12b2:	90 93 27 07 	sts	0x0727, r25	; 0x800727 <pxOverflowDelayedTaskList+0x1>
    12b6:	80 93 26 07 	sts	0x0726, r24	; 0x800726 <pxOverflowDelayedTaskList>
}
    12ba:	00 00       	nop
    12bc:	0f 90       	pop	r0
    12be:	df 91       	pop	r29
    12c0:	cf 91       	pop	r28
    12c2:	08 95       	ret

000012c4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    12c4:	cf 93       	push	r28
    12c6:	df 93       	push	r29
    12c8:	00 d0       	rcall	.+0      	; 0x12ca <prvCheckTasksWaitingTermination+0x6>
    12ca:	1f 92       	push	r1
    12cc:	cd b7       	in	r28, 0x3d	; 61
    12ce:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    12d0:	2b c0       	rjmp	.+86     	; 0x1328 <prvCheckTasksWaitingTermination+0x64>
		{
			vTaskSuspendAll();
    12d2:	24 dd       	rcall	.-1464   	; 0xd1c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    12d4:	90 91 31 07 	lds	r25, 0x0731	; 0x800731 <xTasksWaitingTermination>
    12d8:	81 e0       	ldi	r24, 0x01	; 1
    12da:	99 23       	and	r25, r25
    12dc:	09 f0       	breq	.+2      	; 0x12e0 <prvCheckTasksWaitingTermination+0x1c>
    12de:	80 e0       	ldi	r24, 0x00	; 0
    12e0:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    12e2:	29 dd       	rcall	.-1454   	; 0xd36 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    12e4:	89 81       	ldd	r24, Y+1	; 0x01
    12e6:	88 23       	and	r24, r24
    12e8:	f9 f4       	brne	.+62     	; 0x1328 <prvCheckTasksWaitingTermination+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    12ea:	0f b6       	in	r0, 0x3f	; 63
    12ec:	f8 94       	cli
    12ee:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    12f0:	80 91 36 07 	lds	r24, 0x0736	; 0x800736 <xTasksWaitingTermination+0x5>
    12f4:	90 91 37 07 	lds	r25, 0x0737	; 0x800737 <xTasksWaitingTermination+0x6>
    12f8:	fc 01       	movw	r30, r24
    12fa:	86 81       	ldd	r24, Z+6	; 0x06
    12fc:	97 81       	ldd	r25, Z+7	; 0x07
    12fe:	9b 83       	std	Y+3, r25	; 0x03
    1300:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1302:	8a 81       	ldd	r24, Y+2	; 0x02
    1304:	9b 81       	ldd	r25, Y+3	; 0x03
    1306:	02 96       	adiw	r24, 0x02	; 2
    1308:	28 db       	rcall	.-2480   	; 0x95a <uxListRemove>
					--uxCurrentNumberOfTasks;
    130a:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxCurrentNumberOfTasks>
    130e:	81 50       	subi	r24, 0x01	; 1
    1310:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1314:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <uxTasksDeleted>
    1318:	81 50       	subi	r24, 0x01	; 1
    131a:	80 93 3a 07 	sts	0x073A, r24	; 0x80073a <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1322:	8a 81       	ldd	r24, Y+2	; 0x02
    1324:	9b 81       	ldd	r25, Y+3	; 0x03
    1326:	97 d0       	rcall	.+302    	; 0x1456 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1328:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <uxTasksDeleted>
    132c:	88 23       	and	r24, r24
    132e:	89 f6       	brne	.-94     	; 0x12d2 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    1330:	00 00       	nop
    1332:	0f 90       	pop	r0
    1334:	0f 90       	pop	r0
    1336:	0f 90       	pop	r0
    1338:	df 91       	pop	r29
    133a:	cf 91       	pop	r28
    133c:	08 95       	ret

0000133e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	00 d0       	rcall	.+0      	; 0x1344 <prvAddCurrentTaskToDelayedList+0x6>
    1344:	cd b7       	in	r28, 0x3d	; 61
    1346:	de b7       	in	r29, 0x3e	; 62
    1348:	9a 83       	std	Y+2, r25	; 0x02
    134a:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    134c:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
    1350:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
    1354:	29 81       	ldd	r18, Y+1	; 0x01
    1356:	3a 81       	ldd	r19, Y+2	; 0x02
    1358:	fc 01       	movw	r30, r24
    135a:	33 83       	std	Z+3, r19	; 0x03
    135c:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    135e:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <xTickCount>
    1362:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <xTickCount+0x1>
    1366:	29 81       	ldd	r18, Y+1	; 0x01
    1368:	3a 81       	ldd	r19, Y+2	; 0x02
    136a:	28 17       	cp	r18, r24
    136c:	39 07       	cpc	r19, r25
    136e:	70 f4       	brcc	.+28     	; 0x138c <prvAddCurrentTaskToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1370:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
    1374:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
    1378:	9c 01       	movw	r18, r24
    137a:	2e 5f       	subi	r18, 0xFE	; 254
    137c:	3f 4f       	sbci	r19, 0xFF	; 255
    137e:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <pxOverflowDelayedTaskList>
    1382:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <pxOverflowDelayedTaskList+0x1>
    1386:	b9 01       	movw	r22, r18
    1388:	70 da       	rcall	.-2848   	; 0x86a <vListInsert>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    138a:	1c c0       	rjmp	.+56     	; 0x13c4 <prvAddCurrentTaskToDelayedList+0x86>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    138c:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <pxCurrentTCB>
    1390:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <pxCurrentTCB+0x1>
    1394:	9c 01       	movw	r18, r24
    1396:	2e 5f       	subi	r18, 0xFE	; 254
    1398:	3f 4f       	sbci	r19, 0xFF	; 255
    139a:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <pxDelayedTaskList>
    139e:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <pxDelayedTaskList+0x1>
    13a2:	b9 01       	movw	r22, r18
    13a4:	62 da       	rcall	.-2876   	; 0x86a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    13a6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    13aa:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    13ae:	29 81       	ldd	r18, Y+1	; 0x01
    13b0:	3a 81       	ldd	r19, Y+2	; 0x02
    13b2:	28 17       	cp	r18, r24
    13b4:	39 07       	cpc	r19, r25
    13b6:	30 f4       	brcc	.+12     	; 0x13c4 <prvAddCurrentTaskToDelayedList+0x86>
		{
			xNextTaskUnblockTime = xTimeToWake;
    13b8:	89 81       	ldd	r24, Y+1	; 0x01
    13ba:	9a 81       	ldd	r25, Y+2	; 0x02
    13bc:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    13c0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    13c4:	00 00       	nop
    13c6:	0f 90       	pop	r0
    13c8:	0f 90       	pop	r0
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	08 95       	ret

000013d0 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	cd b7       	in	r28, 0x3d	; 61
    13d6:	de b7       	in	r29, 0x3e	; 62
    13d8:	28 97       	sbiw	r28, 0x08	; 8
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	de bf       	out	0x3e, r29	; 62
    13e0:	0f be       	out	0x3f, r0	; 63
    13e2:	cd bf       	out	0x3d, r28	; 61
    13e4:	9e 83       	std	Y+6, r25	; 0x06
    13e6:	8d 83       	std	Y+5, r24	; 0x05
    13e8:	78 87       	std	Y+8, r23	; 0x08
    13ea:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13ec:	8f 81       	ldd	r24, Y+7	; 0x07
    13ee:	98 85       	ldd	r25, Y+8	; 0x08
    13f0:	89 2b       	or	r24, r25
    13f2:	29 f4       	brne	.+10     	; 0x13fe <prvAllocateTCBAndStack+0x2e>
    13f4:	8d 81       	ldd	r24, Y+5	; 0x05
    13f6:	9e 81       	ldd	r25, Y+6	; 0x06
    13f8:	0e 94 52 00 	call	0xa4	; 0xa4 <pvPortMalloc>
    13fc:	02 c0       	rjmp	.+4      	; 0x1402 <prvAllocateTCBAndStack+0x32>
    13fe:	8f 81       	ldd	r24, Y+7	; 0x07
    1400:	98 85       	ldd	r25, Y+8	; 0x08
    1402:	9c 83       	std	Y+4, r25	; 0x04
    1404:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	9c 81       	ldd	r25, Y+4	; 0x04
    140a:	89 2b       	or	r24, r25
    140c:	b9 f0       	breq	.+46     	; 0x143c <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    140e:	86 e2       	ldi	r24, 0x26	; 38
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	0e 94 52 00 	call	0xa4	; 0xa4 <pvPortMalloc>
    1416:	9a 83       	std	Y+2, r25	; 0x02
    1418:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    141a:	89 81       	ldd	r24, Y+1	; 0x01
    141c:	9a 81       	ldd	r25, Y+2	; 0x02
    141e:	89 2b       	or	r24, r25
    1420:	41 f0       	breq	.+16     	; 0x1432 <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1422:	89 81       	ldd	r24, Y+1	; 0x01
    1424:	9a 81       	ldd	r25, Y+2	; 0x02
    1426:	2b 81       	ldd	r18, Y+3	; 0x03
    1428:	3c 81       	ldd	r19, Y+4	; 0x04
    142a:	fc 01       	movw	r30, r24
    142c:	30 8f       	std	Z+24, r19	; 0x18
    142e:	27 8b       	std	Z+23, r18	; 0x17
    1430:	07 c0       	rjmp	.+14     	; 0x1440 <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1432:	8b 81       	ldd	r24, Y+3	; 0x03
    1434:	9c 81       	ldd	r25, Y+4	; 0x04
    1436:	0e 94 a5 00 	call	0x14a	; 0x14a <vPortFree>
    143a:	02 c0       	rjmp	.+4      	; 0x1440 <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    143c:	1a 82       	std	Y+2, r1	; 0x02
    143e:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    1440:	89 81       	ldd	r24, Y+1	; 0x01
    1442:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1444:	28 96       	adiw	r28, 0x08	; 8
    1446:	0f b6       	in	r0, 0x3f	; 63
    1448:	f8 94       	cli
    144a:	de bf       	out	0x3e, r29	; 62
    144c:	0f be       	out	0x3f, r0	; 63
    144e:	cd bf       	out	0x3d, r28	; 61
    1450:	df 91       	pop	r29
    1452:	cf 91       	pop	r28
    1454:	08 95       	ret

00001456 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
    145a:	00 d0       	rcall	.+0      	; 0x145c <prvDeleteTCB+0x6>
    145c:	cd b7       	in	r28, 0x3d	; 61
    145e:	de b7       	in	r29, 0x3e	; 62
    1460:	9a 83       	std	Y+2, r25	; 0x02
    1462:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    1464:	89 81       	ldd	r24, Y+1	; 0x01
    1466:	9a 81       	ldd	r25, Y+2	; 0x02
    1468:	fc 01       	movw	r30, r24
    146a:	87 89       	ldd	r24, Z+23	; 0x17
    146c:	90 8d       	ldd	r25, Z+24	; 0x18
    146e:	0e 94 a5 00 	call	0x14a	; 0x14a <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    1472:	89 81       	ldd	r24, Y+1	; 0x01
    1474:	9a 81       	ldd	r25, Y+2	; 0x02
    1476:	0e 94 a5 00 	call	0x14a	; 0x14a <vPortFree>
	}
    147a:	00 00       	nop
    147c:	0f 90       	pop	r0
    147e:	0f 90       	pop	r0
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	08 95       	ret

00001486 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    1486:	cf 93       	push	r28
    1488:	df 93       	push	r29
    148a:	00 d0       	rcall	.+0      	; 0x148c <prvResetNextTaskUnblockTime+0x6>
    148c:	cd b7       	in	r28, 0x3d	; 61
    148e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1490:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <pxDelayedTaskList>
    1494:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <pxDelayedTaskList+0x1>
    1498:	fc 01       	movw	r30, r24
    149a:	80 81       	ld	r24, Z
    149c:	88 23       	and	r24, r24
    149e:	39 f4       	brne	.+14     	; 0x14ae <prvResetNextTaskUnblockTime+0x28>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    14a0:	8f ef       	ldi	r24, 0xFF	; 255
    14a2:	9f ef       	ldi	r25, 0xFF	; 255
    14a4:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    14a8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
	}
}
    14ac:	15 c0       	rjmp	.+42     	; 0x14d8 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    14ae:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <pxDelayedTaskList>
    14b2:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <pxDelayedTaskList+0x1>
    14b6:	fc 01       	movw	r30, r24
    14b8:	85 81       	ldd	r24, Z+5	; 0x05
    14ba:	96 81       	ldd	r25, Z+6	; 0x06
    14bc:	fc 01       	movw	r30, r24
    14be:	86 81       	ldd	r24, Z+6	; 0x06
    14c0:	97 81       	ldd	r25, Z+7	; 0x07
    14c2:	9a 83       	std	Y+2, r25	; 0x02
    14c4:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    14c6:	89 81       	ldd	r24, Y+1	; 0x01
    14c8:	9a 81       	ldd	r25, Y+2	; 0x02
    14ca:	fc 01       	movw	r30, r24
    14cc:	82 81       	ldd	r24, Z+2	; 0x02
    14ce:	93 81       	ldd	r25, Z+3	; 0x03
    14d0:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    14d4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	}
}
    14d8:	00 00       	nop
    14da:	0f 90       	pop	r0
    14dc:	0f 90       	pop	r0
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	08 95       	ret

000014e4 <vLEDInit>:

#include <avr/io.h>
#include "led.h"

void vLEDInit(void)
{
    14e4:	cf 93       	push	r28
    14e6:	df 93       	push	r29
    14e8:	cd b7       	in	r28, 0x3d	; 61
    14ea:	de b7       	in	r29, 0x3e	; 62
	DDRB |= _BV(PB5);
    14ec:	84 e2       	ldi	r24, 0x24	; 36
    14ee:	90 e0       	ldi	r25, 0x00	; 0
    14f0:	24 e2       	ldi	r18, 0x24	; 36
    14f2:	30 e0       	ldi	r19, 0x00	; 0
    14f4:	f9 01       	movw	r30, r18
    14f6:	20 81       	ld	r18, Z
    14f8:	20 62       	ori	r18, 0x20	; 32
    14fa:	fc 01       	movw	r30, r24
    14fc:	20 83       	st	Z, r18
}
    14fe:	00 00       	nop
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	08 95       	ret

00001506 <vLEDToggle>:

void vLEDToggle(void)
{
    1506:	cf 93       	push	r28
    1508:	df 93       	push	r29
    150a:	cd b7       	in	r28, 0x3d	; 61
    150c:	de b7       	in	r29, 0x3e	; 62
	PORTB ^= _BV(PB5);
    150e:	85 e2       	ldi	r24, 0x25	; 37
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	25 e2       	ldi	r18, 0x25	; 37
    1514:	30 e0       	ldi	r19, 0x00	; 0
    1516:	f9 01       	movw	r30, r18
    1518:	30 81       	ld	r19, Z
    151a:	20 e2       	ldi	r18, 0x20	; 32
    151c:	23 27       	eor	r18, r19
    151e:	fc 01       	movw	r30, r24
    1520:	20 83       	st	Z, r18
}
    1522:	00 00       	nop
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	08 95       	ret

0000152a <vLEDFlashTask>:
// #define mainNEXT_TASK_3				(tskIDLE_PRIORITY+3)


// TODO: Research moving vLEDFlashTask method to apptasks.c
void vLEDFlashTask(void *pvParms)
{
    152a:	cf 93       	push	r28
    152c:	df 93       	push	r29
    152e:	00 d0       	rcall	.+0      	; 0x1530 <vLEDFlashTask+0x6>
    1530:	00 d0       	rcall	.+0      	; 0x1532 <vLEDFlashTask+0x8>
    1532:	00 d0       	rcall	.+0      	; 0x1534 <vLEDFlashTask+0xa>
    1534:	cd b7       	in	r28, 0x3d	; 61
    1536:	de b7       	in	r29, 0x3e	; 62
    1538:	9e 83       	std	Y+6, r25	; 0x06
    153a:	8d 83       	std	Y+5, r24	; 0x05
	vLEDInit();
    153c:	d3 df       	rcall	.-90     	; 0x14e4 <vLEDInit>
	portTickType xLastWakeTime;
	const portTickType xFrequency = 100;
    153e:	84 e6       	ldi	r24, 0x64	; 100
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	9a 83       	std	Y+2, r25	; 0x02
    1544:	89 83       	std	Y+1, r24	; 0x01
	xLastWakeTime = xTaskGetTickCount();
    1546:	80 dc       	rcall	.-1792   	; 0xe48 <xTaskGetTickCount>
    1548:	9c 83       	std	Y+4, r25	; 0x04
    154a:	8b 83       	std	Y+3, r24	; 0x03

	for(;;) {
		vLEDToggle();
    154c:	dc df       	rcall	.-72     	; 0x1506 <vLEDToggle>
		vTaskDelayUntil(&xLastWakeTime, xFrequency);
    154e:	29 81       	ldd	r18, Y+1	; 0x01
    1550:	3a 81       	ldd	r19, Y+2	; 0x02
    1552:	ce 01       	movw	r24, r28
    1554:	03 96       	adiw	r24, 0x03	; 3
    1556:	b9 01       	movw	r22, r18
    1558:	37 db       	rcall	.-2450   	; 0xbc8 <vTaskDelayUntil>
	}
    155a:	f8 cf       	rjmp	.-16     	; 0x154c <vLEDFlashTask+0x22>

0000155c <main>:
void init(void);

void vApplicationIdleHook( void );

portSHORT main(void)
{
    155c:	af 92       	push	r10
    155e:	bf 92       	push	r11
    1560:	cf 92       	push	r12
    1562:	df 92       	push	r13
    1564:	ef 92       	push	r14
    1566:	ff 92       	push	r15
    1568:	0f 93       	push	r16
    156a:	cf 93       	push	r28
    156c:	df 93       	push	r29
    156e:	cd b7       	in	r28, 0x3d	; 61
    1570:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(vLEDFlashTask, (int8_t*) "LED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL);
    1572:	a1 2c       	mov	r10, r1
    1574:	b1 2c       	mov	r11, r1
    1576:	c1 2c       	mov	r12, r1
    1578:	d1 2c       	mov	r13, r1
    157a:	e1 2c       	mov	r14, r1
    157c:	f1 2c       	mov	r15, r1
    157e:	01 e0       	ldi	r16, 0x01	; 1
    1580:	20 e0       	ldi	r18, 0x00	; 0
    1582:	30 e0       	ldi	r19, 0x00	; 0
    1584:	45 e5       	ldi	r20, 0x55	; 85
    1586:	50 e0       	ldi	r21, 0x00	; 0
    1588:	67 e0       	ldi	r22, 0x07	; 7
    158a:	71 e0       	ldi	r23, 0x01	; 1
    158c:	85 e9       	ldi	r24, 0x95	; 149
    158e:	9a e0       	ldi	r25, 0x0A	; 10
    1590:	3b da       	rcall	.-2954   	; 0xa08 <xTaskGenericCreate>

	vTaskStartScheduler();
    1592:	8f db       	rcall	.-2274   	; 0xcb2 <vTaskStartScheduler>

	return 0;
    1594:	80 e0       	ldi	r24, 0x00	; 0
    1596:	90 e0       	ldi	r25, 0x00	; 0
}
    1598:	df 91       	pop	r29
    159a:	cf 91       	pop	r28
    159c:	0f 91       	pop	r16
    159e:	ff 90       	pop	r15
    15a0:	ef 90       	pop	r14
    15a2:	df 90       	pop	r13
    15a4:	cf 90       	pop	r12
    15a6:	bf 90       	pop	r11
    15a8:	af 90       	pop	r10
    15aa:	08 95       	ret

000015ac <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
    15ac:	cf 93       	push	r28
    15ae:	df 93       	push	r29
    15b0:	cd b7       	in	r28, 0x3d	; 61
    15b2:	de b7       	in	r29, 0x3e	; 62
	//vCoRoutineSchedule();
}
    15b4:	00 00       	nop
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret

000015bc <_exit>:
    15bc:	f8 94       	cli

000015be <__stop_program>:
    15be:	ff cf       	rjmp	.-2      	; 0x15be <__stop_program>
